1) Что такое клиент? Приведи пример, что может быть клиентом.
Клиент — это программное или аппаратное обеспечение, которое инициирует запросы к серверу для получения услуг, данных или ресурсов.
Пример: веб-браузер, почтовый клиент (Gmail), любое приложение (онлайн-банк, например), другой сервер

2) Что такое сервер? Приведи пример, что может быть сервером сервера
Сервер — это устройство или программное обеспечение, которое предоставляет услуги, данные или ресурсы другим устройствам или программам (клиентам) по запросу.
Пример: веб-сервер, БД, DNS

3) Что такое Interface? Приведи пример.
Интерфейс — это точка взаимодействия или способ общения между двумя системами, компонентами, программами или устройствами. Интерфейсы определяют правила, по которым одна часть системы может взаимодействовать с другой, позволяя им обмениваться данными или командами
Пример: Графический пользовательский интерфейс (GUI), Программный интерфейс (API), Интерфейс командной строки (CLI)
Если у вас есть веб-приложение, которое должно получать данные о погоде, оно может использовать API погодного сервиса. API в данном случае является интерфейсом, который позволяет вашему приложению отправлять запросы на сервер с информацией о погоде и получать данные в стандартизированном виде

4) Что такое толстый клиент? Приведи реальный пример, когда клиент считается толстым.
Толстый клиент (или "fat client", "rich client") — это клиентское приложение, которое выполняет значительную часть обработки данных и логики на стороне пользователя, а не на сервере. То есть большая часть работы происходит локально на устройстве пользователя, тогда как сервер используется в основном для хранения данных или передачи информации
Пример: MS Outlook (загрузка и хранение писем на локальном компьютере, оффлайн-доступ к сообщениям, создание и отправка писем (которые синхронизируются с сервером при подключении) или 1С

5) Что  такое тонкий клиент? Приведи реальный пример, когда клиент считается тонким
Тонкий клиент — это клиентское приложение, которое выполняет минимальные функции на стороне пользователя, а основная обработка данных и логика происходят на сервере. Тонкий клиент, как правило, лишь отображает интерфейс и передает запросы серверу, а сервер выполняет основную работу (обработка данных, вычисления) и возвращает результаты клиенту. Тонкий клиент практически не требует вычислительных ресурсов на стороне пользователя, но сильно зависит от подключения к серверу.
Пример: веб-браузер (отображает интерфейс и передает данные, обработка и хранение - на сервере, Google-docs

6) Какие бывают уровни клиент-серверной архитектуры?
- Одноуровневая (монолитная) архитектура (К и С на одной машине)
- Двухуровневая архитектура (клиент-сервер)
Пример: Приложения на базе SQL. Клиент (пользовательский интерфейс) отправляет запрос к серверу (БД), сервер обрабатывает его и возвращает данные.
- Трехуровневая архитектура:
Пример: Веб-приложения. Клиент взаимодействует через браузер, сервер приложений выполняет бизнес-логику (например, взаимодействует с API), а сервер баз данных хранит данные.
- Многоуровневая архитектура (n-tier):
Пример: Корпоративные системы - в таких системах могут быть отдельные серверы для обработки данных, отчетности и взаимодействия с внешними сервисами.

- Peer-to-Peer (P2P) архитектура (хотя это не совсем клиент-серверная модель в традиционном понимании, здесь каждый узел сети может одновременно выступать и как клиент, и как сервер. Уровни не разделяются так строго. 
Пример: Торрент-сети или распределенные системы хранения данных, где каждый участник сети может предоставлять и получать данные.

7) Что такое балансировщик нагрузки (балансировщики)?
Балансировщик нагрузки (англ. Load Balancer) — это программное или аппаратное устройство, которое распределяет входящий трафик или запросы между несколькими серверами для обеспечения высокой доступности, устойчивости и оптимальной производительности системы. 
Основные задачи балансировщика нагрузки:
1) Распределение нагрузки — балансировщик направляет запросы пользователей на разные серверы в зависимости от текущей загруженности каждого сервера.
2) Обеспечение отказоустойчивости — если один сервер выходит из строя, балансировщик автоматически перенаправляет запросы на другие доступные серверы, что помогает избежать простоев.
3) Улучшение производительности — за счёт распределения нагрузки между серверами система может обрабатывать больше запросов одновременно, обеспечивая высокую производительность.
4) Масштабируемость — позволяет легко добавлять новые серверы в систему без необходимости изменять архитектуру приложения, что делает возможным горизонтальное масштабирование.
Виды: программные, аппаратные, облачные

8) Горячий резерв серверов? Холодный резерв серверов? Приведи реальный пример.
1. Горячий резерв серверов (Hot Standby)
Это ситуация, когда резервные серверы находятся в активном режиме и постоянно синхронизированы с основными серверами. Если основной сервер выходит из строя, резервный сервер (или несколько) немедленно берет на себя работу без существенного перерыва в обслуживании. Горячий резерв обеспечивает минимальное время переключения (практически мгновенное).
Пример: Кластер баз данных с репликацией: в такой системе несколько серверов базы данных работают параллельно, при этом данные синхронизируются в режиме реального времени. Если основной сервер базы данных выходит из строя, резервный сервер автоматически берет на себя работу без потери данных или значительной задержки. Это часто используется в банковских системах, где отказоустойчивость критична.
2. Холодный резерв серверов (Cold Standby)
Это ситуация, когда резервные серверы не активны, но готовы к включению в случае сбоя основного сервера. В случае отказа основного сервера нужно вручную или автоматически активировать резервный сервер, загрузить его и перенести на него необходимые данные. Этот процесс может занять некоторое время, так как серверы не синхронизируются постоянно с основными серверами.

9) Чем web service отличается от web server? Приведи пример.
Веб-сервер — это программное обеспечение или аппаратное устройство, которое принимает запросы от клиентов (обычно через браузер) по протоколу HTTP/HTTPS и отвечает на эти запросы, отправляя клиенту веб-страницы или другие ресурсы (файлы, изображения и т.д.).
Веб-сервис — это программный компонент или приложение, которое позволяет другим программам обмениваться данными через интернет с использованием стандартных протоколов, таких как HTTP, SOAP или REST. В отличие от веб-сервера, веб-сервис не предназначен для взаимодействия с пользователями напрямую через браузер — его цель состоит в обмене данными между приложениями.
Пример: вы разрабатываете мобильное приложение, которое должно отображать текущую погоду. Это приложение обращается к веб-сервису (например, OpenWeather API), отправляя HTTP-запрос с нужными параметрами (например, городом), и веб-сервис возвращает JSON-ответ с данными о погоде.
Web server может обслуживать web service. Например, когда клиентское приложение отправляет запрос к API, этот запрос обрабатывается веб-сервером, который направляет его на веб-сервис, а затем возвращает ответ клиенту.
Таким образом, веб-сервер — это инфраструктурный компонент, который обрабатывает HTTP-запросы и доставляет контент, а веб-сервис — это функциональный компонент, который предоставляет данные или услуги другим программам через интернет.

10) Что такое микросервисная архитектура? Приведи реальный пример использования.
Микросервисная архитектура — это подход к разработке программного обеспечения, при котором приложение строится как набор небольших, независимых и слабо связанных сервисов (микросервисов). Каждый микросервис выполняет одну определённую задачу или предоставляет определённую бизнес-функцию, взаимодействуя с другими сервисами через чётко определённые API (например, HTTP REST, gRPC). Эти сервисы можно разрабатывать, развертывать и масштабировать независимо друг от друга.
Как Netflix использует микросервисы:
- Декомпозиция системы: Netflix разделил свои сервисы на множество независимых микросервисов, каждый из которых отвечает за свою часть системы, такие как управление пользователями, рекомендации, стриминг видео, обработка метаданных, анализ просмотра и др.
- Независимое развертывание и масштабирование: например, если сервис стриминга требует большего числа ресурсов из-за высокой нагрузки (например, во время пикового просмотра шоу), этот микросервис может быть масштабирован независимо от остальных частей системы, таких как сервисы аналитики или управления пользователями.
- Использование контейнеров и оркестрации: Netflix активно использует контейнеры (например, Docker) и оркестраторы (такие как Kubernetes) для управления и автоматизации развертывания своих микросервисов по всему миру.
- Отказоустойчивость и изоляция ошибок: Netflix построил сложную систему отказоустойчивости, где сбой одного микросервиса не приводит к полному краху всей системы. Например, если сервис рекомендаций выходит из строя, это не мешает пользователям продолжать стримить контент.

11) Прокси сервер? Приведи пример.
Прокси-сервер (от англ. proxy — «представитель» или «посредник») — это сервер, который выступает посредником между клиентом и целевым сервером, к которому клиент хочет подключиться. Прокси-сервер принимает запросы от клиента, пересылает их на целевой сервер, получает ответ от этого сервера и возвращает его обратно клиенту. 
Основные функции и задачи прокси-сервера:
- Анонимизация: Прокси-сервер скрывает настоящий IP-адрес клиента, заменяя его своим, что позволяет пользователю оставаться анонимным в интернете.
- Кэширование: Прокси-сервер может кэшировать часто запрашиваемые ресурсы (например, веб-страницы или изображения) и предоставлять их пользователям быстрее, не обращаясь каждый раз к целевому серверу.
- Контроль доступа: Прокси-сервер может использоваться для фильтрации контента, блокировки определённых сайтов или управления доступом пользователей к ресурсам интернета.
- Оптимизация трафика: Прокси может сжимать данные, что уменьшает объём передаваемого трафика и ускоряет работу в сети.
- Безопасность: Прокси-сервер может выполнять проверку запросов, фильтрацию подозрительных соединений и защиту от вредоносных сайтов.
- Балансировка нагрузки: Прокси-сервер может распределять запросы пользователей между несколькими серверами для оптимизации нагрузки.
Типы прокси-серверов:
- Прямой (обычный) прокси: Используется для передачи запросов от клиента к целевому серверу.
Пример: Пользователь подключается к веб-сайту через прокси, чтобы скрыть свой реальный IP-адрес.
- Обратный прокси (Reverse Proxy): В отличие от обычного прокси, обратный прокси расположен на стороне сервера и используется для перераспределения входящих запросов к разным серверам внутри сети.
Пример: Веб-сайты, такие как YouTube или Google, могут использовать обратные прокси для балансировки нагрузки между несколькими серверами, что помогает справляться с огромным количеством запросов.

- Анонимные прокси: Эти прокси-серверы скрывают IP-адрес клиента, предоставляя анонимность при работе в интернете.
Пример: В случае использования анонимного прокси при посещении веб-сайта сервер видит IP-адрес прокси, а не клиента.
- Транспарентный (прозрачный) прокси: Этот прокси не скрывает IP-адрес клиента и используется для фильтрации трафика, блокировки сайтов или кэширования.
Пример: В организациях или учебных заведениях транспарентный прокси может использоваться для фильтрации и контроля доступа пользователей к определённым сайтам.


12) VPN? Приведи пример.
VPN (Virtual Private Network) — это технология, которая создаёт зашифрованное соединение (или "туннель") между устройством пользователя и удалённым сервером VPN, через который передаются все данные. Благодаря шифрованию и перенаправлению трафика через VPN-сервер, пользователь может скрыть свой реальный IP-адрес, повысить безопасность соединения и обойти различные ограничения (например, доступ к заблокированным веб-сайтам)
Основные функции и задачи VPN:
- Шифрование данных: VPN шифрует весь трафик между устройством пользователя и VPN-сервером, что делает его нечитабельным для посторонних (например, интернет-провайдеров или злоумышленников).
- Скрытие IP-адреса: VPN заменяет реальный IP-адрес пользователя на IP-адрес VPN-сервера, что позволяет оставаться анонимным в интернете.
- Обход географических блокировок: VPN позволяет пользователю получить доступ к контенту, заблокированному в его стране или регионе, так как при подключении к VPN-серверу в другой стране пользователь может "выглядеть" как находящийся в этой стране.
- Защита в публичных сетях: При подключении к незащищённым публичным сетям (например, Wi-Fi в кафе или аэропорту) VPN обеспечивает безопасность, предотвращая перехват данных злоумышленниками.
- Сокрытие действий в интернете: VPN позволяет скрыть действия в интернете от провайдеров или государственных органов, которые могут отслеживать или ограничивать доступ к ресурсам.

13) Что такое атака Man-in-the-Middle?
Атака "Man in the Middle" (MitM) — это тип кибератаки, при которой злоумышленник перехватывает и потенциально изменяет сообщения между двумя сторонами, которые думают, что они общаются напрямую друг с другом. Проще говоря, злоумышленник становится посредником (или "человеком посередине") между жертвой и целевым сервером, при этом жертва не подозревает о его присутствии.
Как работает атака MitM?
- Перехват трафика: Злоумышленник внедряется в канал связи между клиентом и сервером (например, между компьютером пользователя и веб-сайтом). Это может быть сделано через незащищённую сеть Wi-Fi, с помощью поддельного сетевого устройства или при помощи вредоносного ПО.
- Анализ или изменение данных: После того, как злоумышленник получил доступ к данным, он может:
1. Просто перехватывать и просматривать информацию, например, пароли, личные данные, номера кредитных карт.
2. Изменять данные на лету. Например, изменить содержимое сообщения или подменить информацию в передаваемом пакете данных.
- Передача данных: Жертва может не замечать никаких изменений, так как данные перехватываются и передаются дальше, как будто ничего не произошло.
Основные сценарии атаки:
- Атака в незащищённых Wi-Fi-сетях: Пользователь подключается к общедоступной сети Wi-Fi (например, в кафе или аэропорту), не подозревая, что злоумышленник управляет этой сетью или использует поддельную точку доступа. Все данные, передаваемые через такую сеть, могут быть перехвачены.
- DNS-спуфинг: Злоумышленник перехватывает запросы DNS (службы, которая переводит доменные имена в IP-адреса) и направляет жертву на поддельный веб-сайт. Например, жертва думает, что вводит пароль на сайте банка, но на самом деле отправляет его на сервер злоумышленника.
- HTTPS-спуфинг: Злоумышленник может перехватить HTTPS-соединение и отправить клиенту поддельный сертификат, делая так, что пользователь думает, что соединение защищено, хотя на самом деле оно контролируется злоумышленником.

14) Что такое API?
API (Application Programming Interface) — это интерфейс для программирования приложений, который позволяет различным программным компонентам взаимодействовать между собой. API определяет набор правил и методов, с помощью которых одно программное приложение может запрашивать или отправлять данные другому приложению или сервису.
Виды API:
- REST (Representational State Transfer): Использует стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами.
Пример: API Twitter RESTful позволяет получать твиты, публиковать новые и удалять старые.
- SOAP (Simple Object Access Protocol): Более сложный и формализованный протокол взаимодействия через API. Использует XML для обмена данными и подходит для корпоративных приложений, требующих более строгих стандартов безопасности.
Пример: Некоторые банковские и финансовые системы используют SOAP API для обмена данными между различными системами.
- GraphQL: Это API-интерфейс, который позволяет клиенту запрашивать ровно те данные, которые ему нужны, в отличие от REST, где возвращаются все данные по запросу.
Пример: Facebook использует GraphQL для взаимодействия с серверами и клиентами в своих приложениях.
- WebSocket API: Это API для установления постоянного соединения между клиентом и сервером, что позволяет передавать данные в реальном времени.
Пример: Чат-приложения, такие как Slack, используют WebSocket API для обмена сообщениями в реальном времени.

15) Что такое REST API?
REST API (Representational State Transfer Application Programming Interface) — это тип веб-API, который использует принципы архитектуры REST для взаимодействия между клиентом и сервером через протокол HTTP. REST API позволяет обмениваться данными между клиентом (например, веб-браузером или мобильным приложением) и сервером, используя стандартные HTTP-методы, такие как GET, POST, PUT, DELETE.

16) Требования к архитектуре Rest.
Основные принципы REST:
1. Клиент-серверная архитектура:
В REST архитектура строго разделена на клиент и сервер. Клиент отправляет запросы, а сервер обрабатывает их и возвращает ответы. Клиент и сервер независимы и могут развиваться по отдельности.
2. Отсутствие состояния (stateless):
Сервер не хранит информацию о состоянии клиента между запросами. Каждый запрос должен содержать всю необходимую информацию (например, аутентификационные данные), чтобы сервер мог его обработать.
3. Кэшируемость:
Ответы сервера могут быть кэшированы для повышения производительности. REST API обычно предоставляет информацию о том, какие ответы можно кэшировать и на какое время.
4. Единообразие интерфейса:
REST API использует стандартизированные HTTP методы и ресурсы. Для каждого ресурса определены конкретные операции, что упрощает взаимодействие (GET, POST, PUT, PATCH, DELETE)
5. Именование ресурсов через URI:
Все ресурсы (объекты или данные) идентифицируются с помощью уникальных URI (Uniform Resource Identifier), что позволяет работать с ними через стандартные HTTP запросы. 
6. Отделение представления от данных:
Сервер возвращает данные в виде определенного формата (например, JSON или XML), но не диктует, как эти данные будут отображаться клиентом. Клиент сам решает, как их интерпретировать.
7. Многоуровневость системы:
Архитектура REST поддерживает наличие промежуточных серверов, таких как прокси или балансировщики нагрузки, что позволяет улучшить масштабируемость и производительность.


17) Что такое CRUD?
CRUD — это аббревиатура, которая обозначает четыре основных операции, выполняемых с базами данных или другими хранилищами данных. Эти операции используются для управления данными в приложениях и сервисах.
Create - Read - Update - Delete

18) Чем GET отличается от POST?
1. Назначение:
GET используется для запроса данных с сервера (чтение). Это когда клиент запрашивает информацию, не изменяя ничего на сервере. Пример — загрузка веб-страницы или получение списка товаров.
POST используется для отправки данных на сервер (например, для создания или изменения данных). Пример — отправка формы с регистрацией или добавление комментария на сайте.
2. Расположение данных:
GET передаёт данные через URL в строке запроса (параметры добавляются после вопросительного знака). Пример:
POST передаёт данные в теле запроса, что делает его предпочтительным для передачи больших объёмов данных или конфиденциальной информации. Пример:
3. Безопасность:
GET менее безопасен, так как данные передаются в URL и могут быть легко прочитаны или сохранены в истории браузера. Это делает его непригодным для передачи конфиденциальной информации, такой как пароли или данные кредитных карт.
POST более безопасен, так как данные передаются в теле запроса и не отображаются в URL, что делает его более подходящим для передачи чувствительных данных. Однако он не обеспечивает полную безопасность без использования HTTPS.
4. Объём данных:
GET имеет ограничение на длину URL (ограничено браузером и сервером, обычно до 2048 символов), что делает его неподходящим для передачи больших объёмов данных.
POST не имеет таких ограничений по длине, так как данные передаются в теле запроса, что позволяет отправлять большие файлы или объёмы данных.
5. Кэширование:
GET запросы могут быть закэшированы браузером и сервером, так как они предполагаются безопасными и не изменяющими данные. Это ускоряет повторные запросы тех же данных.
POST запросы не кэшируются, так как они могут изменять состояние сервера, что делает их неподходящими для кэширования.
6. Идемпотентность:
GET является идемпотентным, что означает, что многократное выполнение одного и того же GET-запроса приведёт к одному и тому же результату и не изменит состояние сервера.
POST не идемпотентен — каждый POST-запрос может изменять данные на сервере (например, при отправке одной и той же формы несколько раз может быть создано несколько записей).

19) Чем POST отличается от PUT?
1. Назначение:
POST используется для создания ресурса на сервере. 
PUT используется для обновления ресурса или замены существующего. В случае, если ресурс не существует, PUT может создать его с переданными данными (хотя это зависит от реализации сервера).
2. Идемпотентность:
POST не является идемпотентным
PUT является идемпотентным
3. Где и как создаётся ресурс:
POST: Клиент отправляет данные на сервер, но не указывает, где будет создан новый ресурс. Сервер сам решает, как идентифицировать новый ресурс (например, создавая уникальный идентификатор). Это полезно для отправки формы регистрации или данных новой сущности.
PUT: Клиент указывает конкретное местоположение (URI), где должен находиться ресурс. Если ресурса по этому URI не существует, сервер может создать его. Если ресурс существует, он будет полностью перезаписан новыми данными.
4. Полное обновление vs частичное обновление:
POST чаще используется для частичных операций и создания данных. Если нужно отправить только часть данных (например, только имя и email для нового пользователя), то POST подойдёт.
PUT обычно подразумевает полное обновление ресурса. Это означает, что при отправке PUT-запроса клиент должен передать все поля ресурса, которые необходимо сохранить, иначе сервер может перезаписать пропущенные поля пустыми значениями.
5. Создание через PUT:
PUT может быть использован для создания ресурса, если сервер реализован таким образом, что если ресурс по указанному URI не существует, он будет создан. Например, если клиент отправляет PUT /users/123, а пользователя с ID 123 нет, сервер может создать его с этими данными.
POST не может быть использован для создания ресурса в конкретном месте по URI, как это делает PUT. POST обычно отправляет данные на сервер, а сервер сам решает, где хранить этот новый ресурс.

20) Чем PUT отличается от PATCH?
PUT:
- Используется для замены всего ресурса. Когда вы отправляете запрос PUT, вы должны предоставить полное представление ресурса. Если какие-то поля отсутствуют в запросе, они будут удалены из ресурса на сервере.
Пример: если у вас есть объект с полями name и age, и вы отправите запрос PUT с только полем name, поле age будет удалено.
PATCH:
- Используется для частичного обновления ресурса. С помощью PATCH можно отправить только те поля, которые вы хотите изменить. Остальные поля останутся без изменений.
Пример: используя тот же объект, если вы хотите изменить только поле age, вы можете отправить запрос PATCH с новым значением для age, и поле name останется без изменений.

21) Можно ли в POST передать данные и через URL и через Body?
Да, в HTTP-запросе с методом POST можно передавать данные как через URL, так и через тело (Body) запроса
Параметры через URL (через query string) могут использоваться для передачи идентификаторов, токенов или других элементов, которые проще обрабатывать на стороне сервера как часть пути или query-параметров.
Тело запроса обычно используется для передачи более сложных структур данных:
- JSON: Чаще всего данные передаются в формате JSON.
- application/x-www-form-urlencoded или multipart/form-data: Используются, например, для форм и загрузки файлов.

22) Можно ли с помощью URLa передать данные на сервер?
Да, можно. Через query parameters

23) Что такое идемпотентность?
Идемпотентность - многократное повторение запроса приводит к одну и тому же результату и не меняет состояние сервера

24) В чем разница между безопасностью и идемпотентностью?
Изменение состояния:
- Безопасность фокусируется на том, что операция не должна изменять состояние ресурса. Это строгое ограничение — безопасная операция может только читать данные.
- Идемпотентность допускает изменение состояния ресурса, но оно должно быть идентичным при повторных вызовах. То есть, состояние может измениться, но многократные запросы не приведут к дополнительным изменениям.
Примеры методов:
- GET: Безопасен и идемпотентен.
- PUT: Не безопасен (так как изменяет данные), но идемпотентен (результат будет одинаковым при повторных вызовах).
- DELETE: Не безопасен (удаляет ресурс), но идемпотентен (повторные вызовы не изменят результат — ресурс уже удален).
- POST: Не безопасен и не идемпотентен (каждый вызов может создать новый ресурс).

25) Что такое endpoint?
Endpoint (конечная точка) — это адрес, который используется для взаимодействия с API (интерфейсом программирования приложений). Он представляет собой URL, по которому можно отправлять запросы и получать ответы от сервера.
В контексте веб-приложений, endpoint может относиться к конкретной функции или ресурсу, например, получение списка пользователей, добавление нового заказа и т. д. Каждый endpoint обычно поддерживает определенные HTTP-методы, такие как GET, POST, PUT, DELETE, которые определяют тип операции, выполняемой над ресурсом.

26) Что такое статус код сервера?
Статус-код сервера — это числовое значение, которое сервер возвращает в ответ на HTTP-запрос от клиента. Эти коды помогают понять результат запроса и могут сигнализировать о различных ситуациях, таких как успешное выполнение запроса, ошибки на стороне клиента или сервера и другие состояния.

27) Какие существуют группы?
1xx (Информационные) — означают, что запрос принят и процесс продолжается:
2xx (Успешные) — означают, что запрос успешно обработан:
3xx (Перенаправления) — указывают на то, что требуется дальнейшее действие, например, перенаправление на другой URL:
4xx (Ошибки клиента) — означают, что проблема на стороне клиента:
5xx (Ошибки сервера) — указывают на проблемы на стороне сервера:

28) Какие ты знаешь 5 из 400?
1. 400 Bad Request (Неверный запрос)
Это ошибка возникает, если запрос, отправленный клиентом, имеет некорректный синтаксис, поврежденные данные или не может быть обработан сервером. Часто это связано с неправильным форматом запроса, например, некорректными параметрами в URL.
2. 401 Unauthorized (Неавторизован)
Этот код означает, что доступ к запрашиваемому ресурсу требует авторизации. Обычно сервер возвращает его, когда клиент не предоставил корректные учетные данные (например, логин и пароль). После успешной авторизации ошибка исчезает.
3. 403 Forbidden (Запрещено)
Ошибка 403 возникает, когда сервер понимает запрос клиента, но отказывается его выполнять из-за ограничений прав доступа. Например, у клиента недостаточно прав для просмотра запрашиваемого ресурса, даже если он авторизован.
4. 404 Not Found (Не найдено)
Одна из самых известных ошибок, которая указывает на то, что сервер не может найти запрашиваемый ресурс. Это может произойти, если URL указан неверно или если ресурс был удалён.
5. 405 Method Not Allowed (Метод не разрешён)
Этот код указывает, что метод HTTP, который использовал клиент (например, POST или DELETE), не поддерживается для данного ресурса. Например, если сервер принимает только GET-запросы на определённом пути, а клиент отправляет POST, возникнет ошибка 405.

29) Какие ты знаешь 5 из 500?
1. 500 Internal Server Error (Внутренняя ошибка сервера)
Это общий код, который означает, что на сервере произошла ошибка, но сервер не может конкретно указать, в чем проблема. Это может быть вызвано ошибками в серверных скриптах, сбоями базы данных или другими внутренними проблемами.
2. 501 Not Implemented (Не реализовано)
Этот код указывает, что сервер не поддерживает или не распознает метод, указанный в запросе. Это может быть связано с тем, что функция или метод, требуемый клиентом, не реализован или не поддерживается на сервере.
3. 502 Bad Gateway (Плохой шлюз)
Ошибка возникает, когда сервер, выступающий в роли шлюза или прокси, получил некорректный ответ от вышестоящего сервера. Это часто связано с проблемами связи между серверами или неправильной конфигурацией сети.
4. 503 Service Unavailable (Сервис недоступен)
Этот код указывает, что сервер временно не может обработать запрос, обычно из-за перегрузки или технического обслуживания. В таких случаях сервер может сообщать, когда ожидать восстановления его работоспособности.
5. 504 Gateway Timeout (Шлюз не отвечает)
Возникает, когда сервер, действующий как шлюз или прокси, не получает вовремя ответ от другого сервера. Это может быть связано с медленным интернет-соединением или перегруженным сервером.
6. 505 HTTP Version Not Supported (Версия HTTP не поддерживается)
Этот код указывает, что сервер не поддерживает версию HTTP, используемую в запросе. Это может происходить, если клиент использует устаревшую версию HTTP, которая больше не поддерживается.

30) Какие ты знаешь Headers в Request?
1. General Headers (Общие заголовки):
- Host: Указывает домен и (опционально) порт, к которому направлен запрос. Пример: Host: www.example.com.
- User-Agent: Определяет информацию о клиенте (браузере или приложении), который делает запрос. Пример: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64).
- Accept: Указывает типы контента, которые клиент может обрабатывать. Пример: Accept: text/html, application/json.
- Accept-Encoding: Указывает, какие методы сжатия (например, gzip или deflate) клиент поддерживает. Пример: Accept-Encoding: gzip, deflate.
- Accept-Language: Указывает предпочитаемые языки для ответа от сервера. Пример: Accept-Language: en-US, ru-RU.
- Cache-Control: Управляет кешированием, может запретить кеширование или указать условия его использования. Пример: Cache-Control: no-cache.
2. Authentication Headers (Заголовки аутентификации):
- Authorization: Передает данные для аутентификации пользователя, например, токен в формате Bearer для доступа к защищенным ресурсам. Пример: Authorization: Bearer your_token.
Proxy-Authorization: Используется для аутентификации клиента перед прокси-сервером.
3. Entity Headers (Заголовки сущности):
- Content-Type: Указывает тип данных, которые передаются в теле запроса. Например: Content-Type: application/json для JSON данных или Content-Type: multipart/form-data для отправки файлов.
- Content-Length: Определяет длину тела запроса в байтах. Пример: Content-Length: 348.
- Content-Encoding: Указывает, какое сжатие было применено к телу запроса, если применимо. Пример: Content-Encoding: gzip.
4. Conditional Headers (Условные заголовки):
- If-Modified-Since: Сообщает серверу, что клиент хочет получить ресурс только в том случае, если он был изменён после указанной даты. Пример: If-Modified-Since: Wed, 21 Oct 2020 07:28:00 GMT.
- If-None-Match: Используется для проверки соответствия ETag (уникальный идентификатор версии ресурса). Если ETag совпадает, сервер возвращает 304 Not Modified.
5. CORS Headers (Заголовки для кросс-доменных запросов):
- Origin: Указывает на исходный домен клиента, когда выполняется кросс-доменный запрос (например, при AJAX запросе). Пример: Origin: https://example.com.
- Referer: Указывает URL страницы, с которой был сделан запрос. Пример: Referer: https://example.com/previous-page.
6. Security Headers (Заголовки безопасности):
- Cookie: Передаёт клиентские куки на сервер. Пример: Cookie: sessionId=abc123; csrftoken=xyz456.
- X-CSRF-Token: Используется для защиты от CSRF-атак, передавая токен, подтверждающий подлинность запроса.
7. Custom Headers (Пользовательские заголовки):
- X-Requested-With: Используется для определения того, был ли запрос сделан через XMLHttpRequest (например, AJAX-запрос). Пример: X-Requested-With: XMLHttpRequest.
- X-Forwarded-For: Передает IP-адрес клиента через прокси или балансировщик нагрузки. Пример: X-Forwarded-For: 203.0.113.195.

31) Какие ты знаешь Headers в Responce?
1. General Headers (Общие заголовки):
- Date: Указывает дату и время, когда сервер сгенерировал ответ. 
Пример: Date: Sun, 20 Oct 2024 12:34:56 GMT.
- Server: Информация о сервере, который обрабатывает запрос. 
Пример: Server: Apache/2.4.1 (Unix).
- Connection: Управляет соединением между клиентом и сервером, например, указывает, нужно ли закрыть соединение после завершения ответа. 
Пример: Connection: keep-alive.
2. Entity Headers (Заголовки сущности):
- Content-Type: Указывает тип контента, передаваемого сервером, например, HTML, JSON, изображение и т.д. 
Пример: Content-Type: text/html; charset=UTF-8.
- Content-Length: Указывает длину тела ответа в байтах. 
Пример: Content-Length: 348.
- Content-Encoding: Указывает метод сжатия, использованный для тела ответа (например, gzip или deflate). 
Пример: Content-Encoding: gzip.
- Content-Language: Указывает язык содержимого ответа. 
Пример: Content-Language: en-US.
- Content-Disposition: Указывает, как контент должен обрабатываться на клиенте, например, как вложение для загрузки файла. Пример: Content-Disposition: attachment; filename="example.pdf".
3. Caching Headers (Заголовки кеширования):
- Cache-Control: Управляет кешированием ответа. 
Пример: Cache-Control: no-cache, no-store, must-revalidate.
- Expires: Указывает дату, после которой ответ считается устаревшим и больше не должен кешироваться. 
Пример: Expires: Wed, 21 Oct 2024 07:28:00 GMT.
- ETag: Уникальный идентификатор версии ресурса. Используется для проверки, изменился ли ресурс с момента последнего запроса. 
Пример: ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4".
4. Redirection Headers (Заголовки для перенаправления):
- Location: Используется для указания URL, на который клиент должен быть перенаправлен. Обычно возвращается с кодами 3xx. 
Пример: Location: https://www.example.com/new-page.
5. Security Headers (Заголовки безопасности):
- Set-Cookie: Устанавливает куки для клиента. 
Пример: Set-Cookie: sessionId=abc123; HttpOnly; Secure.
- Strict-Transport-Security (HSTS): Указывает браузеру использовать только HTTPS для всех последующих запросов к серверу. 
Пример: Strict-Transport-Security: max-age=31536000; includeSubDomains.
- X-Frame-Options: Защищает от атак типа clickjacking, указывая, может ли содержимое отображаться в iframe. 
Пример: X-Frame-Options: DENY.
- X-Content-Type-Options: Предотвращает попытки браузеров изменять MIME-тип ответов. Пример: X-Content-Type-Options: nosniff.
- Content-Security-Policy (CSP): Определяет политики безопасности для браузера, такие как ограничение загрузки ресурсов с определенных доменов. 
Пример: Content-Security-Policy: default-src 'self'; img-src https://example.com.
6. CORS Headers (Заголовки для кросс-доменных запросов):
- Access-Control-Allow-Origin: Указывает, какие домены могут делать кросс-доменные запросы к серверу. Пример: Access-Control-Allow-Origin: * (разрешает доступ всем доменам).
- Access-Control-Allow-Methods: Определяет методы HTTP, которые разрешены для кросс-доменных запросов. Пример: Access-Control-Allow-Methods: GET, POST, PUT.
7. Other Useful Headers:
- Retry-After: Указывает время, через которое клиент может повторить запрос, если сервер временно недоступен (например, при 503 Service Unavailable). 
Пример: Retry-After: 120 (через 120 секунд).
- Vary: Указывает, какие заголовки запросов влияют на кеширование ответа. 
Пример: Vary: Accept-Encoding.

32) Из чего состоит запрос HTTP-request?
HTTP-запрос состоит из стартовой строки, заголовков, опциональных параметров и тела запроса.
1. Стартовая строка (Request Line)
Первая строка HTTP-запроса, которая указывает:
- Метод HTTP-запроса (например, GET, POST, PUT, DELETE и т.д.).
- URL — путь к ресурсу, который запрашивается.
- Версия протокола HTTP (например, HTTP/1.1 или HTTP/2).
2. Заголовки запроса (Request Headers)
Заголовки содержат дополнительную информацию о запросе. Они передаются в формате "ключ-значение" и разделены новой строкой. Например:
- Host: Указывает на домен, к которому направлен запрос.
- User-Agent: Информация о клиенте (например, браузере или приложении), который отправляет запрос.
- Accept: Указывает, какие типы контента клиент может принимать (например, HTML, JSON, XML).
3. Тело запроса (Request Body)
Эта часть присутствует только в некоторых типах запросов (например, POST, PUT), когда требуется передать данные на сервер. Тело запроса может содержать данные в различных форматах, таких как:
- JSON
- XML
- Форматированные данные (multipart/form-data для отправки файлов).
4. Параметры запроса (Query Parameters)
Параметры запроса передаются в URL после символа ?. Они используются для передачи данных в виде пары "ключ-значение". 
5. Cookies (Куки)
Клиент может отправлять куки, полученные от сервера в предыдущих запросах. Это может быть полезно для сохранения сеансов, аутентификации и хранения пользовательских данных.
Пример:
Полный пример HTTP-запроса:
GET /page.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9
Cookie: sessionId=abc123

33) Из чего состоят ответы HTTP-response?
HTTP-ответ состоит из стартовой строки, набора заголовков, пустой строки и, при наличии, тела ответа
1. Стартовая строка (Status line):
Строка статуса включает три элемента:
- Версия протокола: указывает версию HTTP (например, HTTP/1.1, HTTP/2).
- Код состояния (Status code): трёхзначный числовой код, указывающий результат выполнения запроса (например, 200 для успеха, 404 для "не найдено", 500 для ошибки сервера).
- Статусное сообщение (Reason phrase): краткое описание кода состояния (например, "OK" для 200 или "Not Found" для 404).
2. Заголовки (Headers):
Параметры, которые передают дополнительную информацию о сервере, типе контента, кодировке, политике кеширования и т.д. Заголовки передаются в формате "ключ: значение", каждый из них находится на новой строке.
3. Пустая строка (Empty line):
Эта строка отделяет заголовки от тела ответа. После заголовков всегда следует пустая строка, сигнализирующая, что далее пойдет содержимое.
4. Тело ответа (Body):
Это основное содержимое ответа, которое зависит от типа запроса и ответа сервера. Оно может содержать HTML-документ, изображение, JSON-данные и другие типы контента. Тело ответа может быть пустым, например, в ответе на запрос с кодом 204 (No Content).
Пример полного HTTP-ответа:
HTTP/1.1 200 OK
Date: Mon, 21 Oct 2024 14:28:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Length: 138

34) Что такое и какая разница: Идентификация, Аутентификация, Авторизация?
- Идентификация — это процесс определения личности пользователя или устройства.
Пример: Вы вводите в систему свой логин (имя пользователя). Это идентификация — вы заявляете, кто вы есть.
- Аутентификация — это процесс проверки личности, которую заявил пользователь на этапе идентификации.
Пример: Вы вводите пароль после логина. Система проверяет, соответствует ли этот пароль тому, который был сохранен при создании аккаунта. Если пароли совпадают — вы аутентифицированы.
- Авторизация — это процесс предоставления прав доступа пользователю к определенным ресурсам или действиям, основываясь на его аутентификации и ролях.
Пример: После успешного входа в систему вы можете зайти на свою страницу, но не на страницу другого пользователя. Это определяется вашей авторизацией — у вас есть права только на доступ к своим данным.

35) Что происходит при валидации на сервере?
Валидация на сервере — это процесс проверки данных, отправленных клиентом (например, пользователем через форму на сайте), для подтверждения их корректности и соответствия установленным правилам. Основная цель валидации на сервере — убедиться, что данные безопасны и соответствуют ожиданиям перед их обработкой, сохранением или использованием.
1. Получение данных:
- Сервер получает данные, отправленные клиентом, как часть HTTP-запроса (чаще всего это POST или PUT запросы).
- Эти данные могут поступить через формы, файлы, заголовки HTTP или параметры URL.
2. Проверка структуры данных:
- Сервер проверяет, пришли ли все необходимые поля. Например, если форма требует поля "имя", "email" и "пароль", сервер проверяет, присутствуют ли они все в запросе.
- Проверяются обязательные поля, и если какого-то поля не хватает, сервер возвращает ошибку (например, "400 Bad Request").
3. Проверка типов данных:
- Сервер проверяет, соответствуют ли данные ожидаемым типам. Например:
Если поле должно содержать число (например, возраст), сервер проверяет, является ли оно числом или если поле должно содержать строку (например, имя пользователя), проверяется, что это текст.
4. Проверка форматов:
- Сервер проверяет, соответствуют ли данные требуемому формату. 
Примеры:
- Email: проверяется наличие "@" и других элементов, чтобы убедиться, что это допустимый адрес электронной почты.
- Пароль: может проверяться длина и наличие специальных символов, цифр и букв в разных регистрах.
- Дата: проверяется, что дата имеет правильный формат (например, YYYY-MM-DD).
5. Проверка диапазонов и ограничений:
- Сервер проверяет, находятся ли значения в пределах допустимых диапазонов или ограничений:
Например, если поле для возраста должно содержать значение от 18 до 99, сервер проверяет, что введенное значение попадает в этот диапазон или если поле имеет ограничение по длине, например, имя пользователя не должно быть длиннее 20 символов, сервер это проверяет.
6. Проверка на уникальность (при необходимости):
Если необходимо убедиться, что данные уникальны (например, email или имя пользователя должны быть уникальными в базе данных), сервер проверяет, есть ли уже такая запись в базе данных, а если запись уже существует, сервер возвращает сообщение об ошибке, уведомляя, что такие данные уже используются.
7. Проверка логических условий:
- Иногда требуется более сложная проверка, связанная с бизнес-логикой:
Например, если система продает билеты, сервер может проверить, что количество билетов не превышает доступное количество.
Если требуется согласие с пользовательским соглашением, сервер проверяет, что соответствующий флажок был установлен.
8. Очистка данных (Sanitization):
- Сервер может "очистить" данные от опасных или нежелательных символов:
Например, удаление HTML или JavaScript-кода, чтобы предотвратить атаки типа XSS (Cross-Site Scripting) или удаление неразрешенных символов, таких как специальные символы в именах пользователей.
9. Обработка ошибок:
- Если данные не прошли валидацию, сервер формирует ответ с описанием ошибок. Чаще всего это будет ответ с кодом 400 (Bad Request) и объяснением того, какие именно ошибки произошли (например, "email имеет неверный формат", "пароль слишком короткий").
10. Переход к основной логике:
- Если данные успешно прошли валидацию, сервер продолжает выполнение запроса. Например, данные могут быть сохранены в базе данных, отправлены на сторонние сервисы или использованы для вычислений.

36) Что происходит при валидации на клиенте?
Валидация на клиенте — это процесс проверки корректности данных, введенных пользователем, непосредственно на стороне клиента (обычно в браузере), до того, как они будут отправлены на сервер. Цель такой валидации — повысить удобство использования и уменьшить нагрузку на сервер, поскольку ошибки могут быть выявлены и исправлены быстрее без необходимости отправки данных на сервер.
1. Проверка обязательных полей:
- Проверяется наличие значений в обязательных полях формы. Если какое-то обязательное поле оставлено пустым, пользователю сразу выводится ошибка.
В HTML это можно сделать, добавив атрибут required:
<input type="text" name="username" required>
2. Проверка форматов данных:
- Данные, введенные пользователем, проверяются на соответствие определенным форматам. Например, электронная почта должна содержать символ "@" и правильный домен, а номер телефона должен состоять только из цифр.
Это можно делать с помощью стандартных HTML-атрибутов или JavaScript:
<input type="email" name="user_email" required>
3. Проверка длины данных:
- Проверяется, соответствует ли введенное значение требованиям по минимальной и максимальной длине. Например, пароль должен содержать минимум 8 символов, а имя пользователя — не более 20 символов.
Это можно делать как с помощью HTML-атрибутов, так и через JavaScript:
<input type="password" name="password" minlength="8" maxlength="20" required>
4. Проверка числовых значений:
- Для числовых полей можно проверять диапазон допустимых значений. Например, возраст пользователя может быть от 18 до 99 лет.
HTML-атрибуты:
<input type="number" name="age" min="18" max="99" required>
5. Проверка совпадений (например, паролей):
- Часто требуется убедиться, что два поля, такие как "пароль" и "подтверждение пароля", совпадают. Эта проверка осуществляется с помощью JavaScript.
6. Проверка уникальности (в рамках страницы):
- Иногда валидация может проверять, чтобы данные, введенные пользователем, были уникальны, например, для имени пользователя или email. Это может быть реализовано на клиенте, если есть соответствующие данные, хотя чаще проверка уникальности делается на сервере.
7. Проверка пользовательских соглашений и чекбоксов:
- Для полей типа "чекбокс" (например, подтверждение согласия с условиями использования) проверяется, был ли установлен соответствующий флажок.
В HTML это делается через атрибут required:
8. Проверка файлов (формат и размер):
- Для полей загрузки файлов можно проверить, соответствуют ли загружаемые файлы допустимым форматам (например, изображение должно быть в формате PNG, JPEG) и не превышают ли они допустимый размер.
9. Обратная связь для пользователя (UI):
- Когда пользователь вводит некорректные данные, валидатор на клиенте может сразу сообщить об этом с помощью сообщений об ошибках. Это могут быть всплывающие подсказки, выделение полей красным цветом и т.д.

37) Что такое токен?
Токен в контексте компьютерных систем — это единица данных, которая используется для аутентификации, авторизации или передачи информации в безопасных коммуникациях между клиентом и сервером. Токены часто применяются для замены традиционных сессий с идентификаторами и обеспечивают безопасный доступ к ресурсам.
Примеры:
1. Токен аутентификации:
Это временная сущность, которая подтверждает личность пользователя после успешного входа в систему. Пользователь проходит аутентификацию (например, вводит логин и пароль), после чего сервер выдает токен, который клиент использует для дальнейшего взаимодействия с сервером.
Пример: JWT (JSON Web Token) — широко используемый стандарт токенов.
Как это работает:
- Пользователь вводит свои учетные данные (например, логин и пароль).
- Сервер проверяет эти данные и, если они корректны, генерирует токен.
- Этот токен отправляется пользователю, который хранит его (например, в cookies или local storage).
- При каждом последующем запросе пользователь отправляет токен на сервер для аутентификации. Сервер проверяет токен и решает, можно ли предоставить доступ к запрашиваемым ресурсам.
2. Токен авторизации:
Этот токен используется для предоставления прав доступа к определенным ресурсам или операциям после успешной аутентификации. Авторизация происходит после проверки, действительно ли у пользователя есть права на выполнение определенного действия или доступ к конкретным данным.
Пример: Токены OAuth2, которые используются для доступа к API третьих сторон (например, авторизация через Google или Facebook).
3. Токен доступа (Access Token):
Это токен, который предоставляет доступ к защищенным ресурсам. Его можно получить после аутентификации и с его помощью выполнять различные действия в системе.
Пример: В OAuth2 токен доступа используется для доступа к ресурсам через API.
4. Обновляющий токен (Refresh Token):
Токен, который позволяет клиенту получить новый токен доступа без необходимости повторной аутентификации. Обычно используется для продления сеанса пользователя.
Пример: В OAuth2, когда токен доступа истекает, с помощью refresh token можно запросить новый токен доступа.
5. Токен CSRF (Cross-Site Request Forgery Token):
Это специальный токен, используемый для защиты веб-приложений от атак типа "подделка межсайтовых запросов" (CSRF). Он включается в форму или запрос, чтобы сервер мог убедиться, что запрос был инициирован доверенным источником (клиентом).
6. Токен в криптографии:
В криптографии токены используются для замены важных данных на суррогатные значения, чтобы повысить безопасность. Например, токенизация используется для защиты данных кредитных карт, где реальный номер карты заменяется случайным токеном. Этот токен может передаваться через сеть без риска раскрытия реальных данных.
Пример: JWT (JSON Web Token):
Один из самых популярных форматов токенов в веб-приложениях. JWT состоит из трех частей:
- Header (Заголовок): Содержит тип токена (например, JWT) и алгоритм шифрования.
- Payload (Полезная нагрузка): Содержит данные, такие как идентификатор пользователя, его роль и срок действия токена.
- Signature (Подпись): Подпись, которая создается на основе заголовка и полезной нагрузки с использованием секретного ключа. Она служит для проверки целостности токена.

Преимущества использования токенов:
1. Безопасность: Токены, такие как JWT, подписываются на сервере, что обеспечивает их защиту от подделки. Кроме того, токены могут быть закодированы для защиты данных.
2. Статус-клиент: В отличие от традиционных сессионных механизмов, когда состояние сохраняется на сервере, токены содержат всю необходимую информацию о пользователе, что позволяет серверу быть "бессостоящим".
3. Гибкость: Токены могут использоваться в различных системах, включая веб-приложения и мобильные приложения. Они также поддерживают кросс-доменные запросы.
4. Масштабируемость: Поскольку состояние (информация о пользователе) содержится в токене, серверам не нужно сохранять сессионные данные, что облегчает масштабирование приложений.
Недостатки:
1. Безопасность при хранении на клиенте: Если токен будет скомпрометирован (например, украден с local storage), злоумышленник сможет получить доступ к защищенным ресурсам.
2. Истечение срока действия: Токены имеют фиксированный срок действия, и если он истечет, необходимо заново пройти процесс аутентификации или использовать refresh token.

38) Где хранится токен?
Токен может храниться на стороне клиента в различных местах в зависимости от целей и требований безопасности. Основная задача — обеспечить безопасное хранение токена, чтобы злоумышленники не могли получить к нему доступ и использовать для несанкционированного доступа к системе.
Основные места хранения токенов на клиенте:
1. Local Storage (Локальное хранилище)
Local Storage — это механизм браузера для хранения данных, который сохраняет данные даже после закрытия вкладки или браузера. Токены могут храниться здесь с помощью JavaScript.
Преимущества:
- Токен доступен между сессиями, что упрощает реализацию функционала "запомнить меня".
- Простота доступа к данным.
Недостатки:
- Уязвимость для XSS-атак (Cross-Site Scripting): Если злоумышленник сможет внедрить вредоносный код на сайт, он может получить доступ к токенам в Local Storage.
- Нет защиты от перехвата запроса с токеном (без использования защищенных методов отправки).
2. Session Storage (Сессионное хранилище)
Session Storage — это другой механизм браузера, похожий на Local Storage, но данные хранятся только на время текущей сессии. После закрытия вкладки или браузера данные удаляются.
Преимущества:
- Токен доступен только в пределах одной сессии, что снижает риски, связанные с хранением токенов после завершения работы.
- Блокирует доступ к токенам после закрытия браузера.
Недостатки:
- Уязвимость для XSS-атак так же, как и Local Storage.
- Не подходит для долгосрочной аутентификации (например, "запомнить меня").
3. Cookies (Куки)
Cookies — это данные, которые браузер хранит и автоматически отправляет на сервер при каждом запросе к соответствующему домену. Токен может храниться в cookies с дополнительными флагами безопасности.
Преимущества:
- HttpOnly: Если установить этот флаг, JavaScript не сможет получить доступ к cookie, что защищает его от XSS-атак.
- Secure: Токен будет передаваться только через HTTPS, что защищает его от перехвата через незащищенные соединения.
- SameSite: Флаг защищает от CSRF-атак, предотвращая автоматическую отправку cookie при кросс-доменных запросах.
Недостатки:
- Уязвимость для CSRF-атак, если не используются флаги безопасности, такие как SameSite и HttpOnly.
- Ограничение по размеру: Куки могут содержать ограниченное количество данных (около 4KB), что может быть проблемой для сложных токенов.
4. In-Memory (Память приложения)
Временное хранение токенов в оперативной памяти приложения (например, в переменной JavaScript).
Преимущества:
- Максимальная защита от XSS-атак: Токен не хранится на постоянной основе, а значит, не доступен между сессиями или при перезагрузке страницы.
- Токен исчезает сразу после перезагрузки страницы или закрытия приложения.
Недостатки:
- Токен не сохраняется при перезагрузке страницы, что может ухудшить пользовательский опыт.
- Нужно заново получать токен или использовать другой метод для длительных сессий (например, refresh token).
Как выбрать место хранения токена?
Выбор места хранения зависит от требований к безопасности и удобству использования. Вот основные рекомендации:
Если нужна безопасность:
- Cookies с флагом HttpOnly и Secure: Это предпочтительный вариант, так как токен не будет доступен для JavaScript и будет передаваться только по защищенным каналам (HTTPS). Используйте также флаг SameSite=Strict для защиты от CSRF-атак.
- In-Memory: Подходит для одностраничных приложений (SPA), где требуется минимизация рисков XSS-атак.
Если нужен баланс между удобством и безопасностью:
- Session Storage: Подходит для приложений, где токен должен действовать только во время активной сессии.
- Local Storage: Можно использовать, если не требуется максимальная безопасность и нет строгих требований к защите от XSS. В таком случае нужно дополнительно позаботиться о безопасности клиентского кода.

39) Что такое токен авторизации? Объясни процесс токен авторизации?
Токен авторизации — это временная цифровая сущность, которая используется для предоставления доступа к защищенным ресурсам после успешной аутентификации. Он обычно применяется для передачи прав пользователя или приложения в процессе взаимодействия с API или веб-сервисами. Основная цель токена авторизации — подтвердить, что у пользователя есть необходимые права для выполнения определенных действий или доступа к ресурсам.Примером системы с токенами авторизации является OAuth 2.0, который широко используется для авторизации при доступе к API (например, через Google, Facebook и другие сервисы).
Процесс:
1. Аутентификация пользователя:
- Пользователь или приложение должны пройти аутентификацию. 
- После того, как сервер проверил введенные учетные данные и подтвердил, что они корректны, сервер выдает токен. Токен обычно имеет ограниченный срок действия и используется для дальнейших запросов.
2. Получение токена доступа (Access Token):
- После успешной аутентификации сервер генерирует токен доступа. Это строка, которая представляет собой "билет" на доступ к защищенным ресурсам.
- Этот токен содержит информацию о пользователе и его правах доступа, а также может быть подписан для защиты от подделки. В случае использования JWT (JSON Web Token) токен состоит из трех частей: заголовка (header), полезной нагрузки (payload) и подписи (signature).
3. Использование токена для доступа к ресурсам:
- После получения токена клиент (например, браузер или мобильное приложение) использует этот токен для доступа к защищенным ресурсам. Вместо того, чтобы передавать логин и пароль при каждом запросе, клиент отправляет токен в заголовке запроса к серверу.
Обычно токен передается в заголовке Authorization:
GET /protected-resource HTTP/1.1
Host: api.example.com
Authorization: Bearer your_access_token_here
4. Проверка токена сервером:
- Сервер, получив запрос с токеном, проверяет его:
Подпись: Проверяется, что токен не был подделан, и его подпись соответствует подписанному сервером ключу.
Срок действия: Токен имеет срок действия, и если он истек, сервер отклоняет запрос.
Права пользователя: В зависимости от информации, хранящейся в токене (например, роли пользователя), сервер определяет, имеет ли клиент право на доступ к запрашиваемым ресурсам.
Если токен валиден и клиент имеет необходимые права, сервер предоставляет доступ к запрашиваемому ресурсу.
5. Истечение срока действия и обновление токена (Refresh Token):
- Access Token обычно имеет ограниченный срок действия (например, 15 минут или 1 час). После его истечения необходимо получить новый токен.
- Для этого используется Refresh Token — специальный токен, который имеет более длительный срок действия (иногда несколько дней или недель). Клиент может отправить этот токен на сервер для запроса нового Access Token без необходимости повторной аутентификации пользователя.
В ответ сервер вернет новый Access Token, который клиент может использовать для дальнейших запросов.

40) Может ли быть авторизация без аутентификации? Приведи пример.
Да, авторизация может происходить без аутентификации, хотя это редкий и специфический случай.
Пример:
Открытые веб-ресурсы с ограниченным доступом: Представим себе веб-сайт, который предоставляет бесплатный контент для всех пользователей, но для доступа к определённым разделам сайта (например, для скачивания файлов или публикации комментариев) необходимо просто подтвердить, что пользователь является человеком, используя CAPTCHA. В этом случае система не проверяет личность пользователя (отсутствие аутентификации), но при этом предоставляет доступ (авторизация) после прохождения CAPTCHA. Здесь важно только подтвердить, что пользователь не является ботом, а не кто он на самом деле.

41) Что такое куки?
Куки (cookies) — это небольшие текстовые файлы, которые веб-сайты сохраняют на устройстве пользователя (компьютере, смартфоне и т. д.) через браузер. Они содержат данные, которые могут использоваться для различных целей, таких как запоминание предпочтений пользователя, управление сессиями и отслеживание активности на сайте.
Основные типы куки:
1. Сессионные куки:
- Сохраняются временно и удаляются сразу после закрытия браузера.
- Используются для управления сессией пользователя (например, для того, чтобы пользователь оставался авторизованным на сайте при перемещении между страницами).
2. Постоянные куки:
- Сохраняются на устройстве пользователя в течение определённого времени (например, несколько дней, месяцев или лет).
- Используются для сохранения настроек или предпочтений пользователя между визитами на сайт (например, сохранение данных авторизации для автоматического входа).
3. Куки сторонних сайтов (third-party cookies):
- Создаются не тем сайтом, который посетил пользователь, а сторонними сервисами, например, рекламными сетями или аналитическими платформами.
- Часто применяются для отслеживания поведения пользователя на разных сайтах и показа таргетированной рекламы.

42) Что такое теплый клиент?
Теплый клиент — это клиент, который уже имеет активную сессию или сохраненное состояние. Он может повторно использовать данные, такие как токены аутентификации, и сервер может быстрее обрабатывать его запросы, поскольку знает, что это за клиент и какие действия он ранее выполнял. Это значительно улучшает производительность и удобство взаимодействия.

43) Что такое холодный клиент?
Холодный клиент — это клиент, который инициирует соединение с сервером, не имея никакого сохраненного состояния или контекста. Например, это может быть пользователь, который только что открыл приложение или сайт и не имеет ранее сохраненных данных о своей сессии. Каждый запрос обрабатывается сервером как новый, и для него может потребоваться полная аутентификация и передача всех необходимых данных.

44) Что такое кеш?
Кеш (cache) — это механизм временного хранения данных, который используется для ускорения доступа к часто запрашиваемой информации. Вместо того чтобы повторно запрашивать данные из более медленного источника (например, с жёсткого диска, удалённого сервера или базы данных), кеш хранит их в более быстром доступе, таком как оперативная память (RAM) или на локальном устройстве, что позволяет значительно ускорить обработку запросов.
Основные виды кеша:
1. Кеш процессора (CPU cache):
Это небольшая, но очень быстрая память, встроенная в процессор компьютера. Она используется для временного хранения данных и инструкций, которые процессор часто использует. Благодаря кешу процессор не обращается каждый раз к медленной оперативной памяти, что увеличивает производительность.
2. Кеш в оперативной памяти (RAM cache):
Операционная система или программы могут использовать часть оперативной памяти для хранения данных, к которым требуется быстрый доступ. Это ускоряет выполнение операций, поскольку доступ к RAM гораздо быстрее, чем к жёсткому диску.
3. Кеш браузера:
Веб-браузеры сохраняют копии загруженных веб-страниц, изображений и других ресурсов на локальном диске. Это позволяет ускорить повторную загрузку сайтов, поскольку браузеру не нужно запрашивать все данные у сервера заново — они подгружаются из кеша.
4. Кеш на сервере:
В серверных приложениях и базах данных кеширование используется для ускорения доступа к часто запрашиваемым данным. Например, в веб-серверах кеш может хранить результаты выполнения сложных запросов к базе данных или статические файлы, чтобы не генерировать их заново при каждом запросе.
5. DNS-кеш:
Кеширование DNS-запросов позволяет компьютеру или маршрутизатору временно сохранять IP-адреса доменов, к которым ранее осуществлялся доступ. Это ускоряет повторное обращение к тем же доменам, так как не требуется повторный запрос к DNS-серверу.
- Преимущества кеша:
1. Ускорение доступа: Кеширование позволяет значительно сократить время загрузки данных, так как доступ к кешу быстрее, чем к исходному источнику.
2. Снижение нагрузки на сервер: Часто запрашиваемые данные могут извлекаться из кеша, что уменьшает количество обращений к серверу и снижает его нагрузку.
3. Экономия ресурсов: Кеширование снижает потребление сетевых ресурсов и увеличивает общую производительность системы.
- Недостатки кеша:
1. Устаревшие данные: В кеш иногда могут сохраняться устаревшие данные, что может привести к тому, что пользователь увидит старую версию сайта или приложения.
2. Память: Для хранения данных в кеше требуется выделение памяти, и если её становится слишком много, это может снизить общую производительность системы.
3. Сложность управления: Порой необходимо очищать кеш вручную, если в нём остаются некорректные или устаревшие данные.

45) Для чего используется кэширование страниц?
Кэширование страниц — это процесс сохранения копий веб-страниц (или их частей) на сервере, в браузере пользователя или в промежуточных точках сети (например, в CDN), чтобы ускорить их последующую загрузку. Цель кэширования — уменьшить время ответа сервера и повысить производительность, обеспечивая более быструю доставку контента пользователю без необходимости повторной генерации страницы каждый раз.

46) Для чего необходимо сбрасывать кэш и куки?
1. Обновление устаревших данных
Кеш сохраняет копии веб-страниц и ресурсов. Однако, если на сайте произошли изменения (например, обновление дизайна, контента или кода), браузер может по-прежнему загружать старые данные из кеша, что приводит к тому, что пользователю показываются устаревшие страницы или элементы.
2. Исправление ошибок в работе веб-сайтов
Иногда кешированные данные или куки могут быть повреждены или конфликтовать с текущей версией сайта, что вызывает ошибки в его работе. Например, сайт может некорректно загружаться, выдавать ошибки, отображать неполные страницы или неправильно работать функционал (например, кнопки, формы и т. д.).
3. Устранение проблем с авторизацией и входом
Куки хранят информацию о сессиях пользователей и их действиях на сайте (например, данные для автоматического входа или настройки). Однако куки могут устареть или быть некорректно сохранены, что может вызвать проблемы с авторизацией. Например, пользователь может столкнуться с проблемами при входе на сайт, когда сессия неправильно распознается.
4. Повышение безопасности и конфиденциальности
Куки могут хранить чувствительную информацию, такую как данные авторизации, предпочтения пользователя и информацию о посещаемых сайтах. Со временем это может представлять угрозу безопасности, особенно если куки не обновляются или используются злоумышленниками для отслеживания действий пользователя.
5. Снижение использования дискового пространства
Кешированные данные могут занимать значительное место на жёстком диске или в хранилище устройства. Со временем кеш может накапливать большое количество данных, что может замедлить работу браузера или самого устройства.

47) Что такое сессия?
Сессия — это временное взаимодействие между пользователем и системой (например, веб-сайтом или приложением), которое начинается, когда пользователь заходит на сайт, и заканчивается, когда он выходит или проходит определённый период бездействия. Сессии используются для того, чтобы отслеживать действия пользователя на сайте, хранить его данные, настройки или состояние между запросами, пока он не завершит работу.
Характеристики:
1. Уникальный идентификатор:
- Каждой сессии присваивается уникальный идентификатор (например, session ID), который позволяет системе связывать пользователя с его действиями и данными. Этот идентификатор передаётся между сервером и клиентом (браузером) и используется для отслеживания состояния пользователя.
- Идентификатор сессии часто хранится в куки, хотя могут использоваться и другие способы (например, в URL).
2. Сохранение данных между запросами:
- Поскольку HTTP-протокол является статическим и не сохраняет состояние между запросами, сессия позволяет серверу "запоминать" пользователя и данные о нём, такие как авторизация, выбранные товары в корзине, настройки пользователя и прочее.
3.Кратковременность:
- Сессия имеет ограниченное время жизни. Обычно она истекает через определённый промежуток времени, если пользователь неактивен (например, через 30 минут бездействия), или завершает работу вручную (например, нажав на кнопку "Выйти").

48) Какие стореджи браузера ты знаешь?
- Cookies (куки) — небольшие данные, которые используются для хранения информации о сессии пользователя, аутентификации и предпочтениях.
- LocalStorage — хранит данные в формате ключ-значение и сохраняет их даже после закрытия браузера. Используется для долгосрочного хранения (5-10 MB).
- SessionStorage — схож с LocalStorage, но данные хранятся только на время сессии (пока открыта вкладка).
- IndexedDB — более мощная система хранения, которая позволяет сохранять большие объемы структурированных данных, поддерживая транзакции.
- Cache Storage — используется для кэширования ресурсов (например, для работы веб-приложений офлайн).

49) В чем разница между Session storage и Local storage?
1. Срок хранения данных:
- SessionStorage: Данные хранятся только в рамках одной сессии браузера. Они удаляются, как только пользователь закрывает вкладку или окно браузера.
- LocalStorage: Данные сохраняются на постоянной основе и остаются доступными даже после закрытия браузера или перезагрузки компьютера. Их нужно удалять вручную или программно.
2. Область видимости:
- SessionStorage: Данные видимы только в пределах одной вкладки или окна. Если открыть тот же сайт в новой вкладке, он не получит доступа к данным из SessionStorage предыдущей вкладки.
- LocalStorage: Данные доступны во всех вкладках и окнах браузера для конкретного домена. Это значит, что любой сеанс на одном и том же сайте (в одной браузерной сессии) может получить доступ к данным.

51) Что такое REST 
REST (Representational State Transfer) — это архитектурный стиль, который используется для создания сетевых сервисов и взаимодействия между клиентом и сервером через HTTP-протокол. REST основывается на наборе принципов и ограничений, которые делают его простым и эффективным для разработки веб-API.
Преимущества REST:
- Простота: Использует широко известные и понятные принципы HTTP.
- Гибкость: Могут быть использованы разные форматы данных (JSON, XML, текст).
- Масштабируемость: Благодаря независимости клиента и сервера REST легко масштабируется.
- Поддержка кэширования: Кэширование может значительно повысить производительность API.

52) Что такое SOAP
SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями между приложениями через сеть, обычно по протоколу HTTP. SOAP является более строгим и формализованным по сравнению с REST, так как имеет четкие стандарты для структуры сообщений, описания операций и взаимодействия с удаленными сервисами.

53) Чем REST отличается от SOAP?
1. Архитектурный стиль vs. Протокол
- REST: Это архитектурный стиль, который использует стандартные методы HTTP для взаимодействия с веб-сервисами. REST не имеет жестких стандартов или форматов, что делает его гибким и легким для использования.
- SOAP: Это протокол для обмена сообщениями, который имеет строгие стандарты для формата данных (XML) и поддерживает множество расширений (безопасность, транзакции и т.д.).
2. Формат данных
- REST: Поддерживает различные форматы данных, такие как JSON, XML, HTML, Plain Text и другие. Наиболее часто используется JSON из-за его легкости и простоты.
- SOAP: Всегда использует XML для представления данных. Это более сложный и тяжелый формат, который может содержать дополнительные метаданные и требует больше ресурсов для обработки.
3. Простота и сложность
- REST: Более легкий и простой в реализации. Он полагается на стандартные методы HTTP (GET, POST, PUT, DELETE и т.д.) и не требует сложных спецификаций для описания API. Это делает его идеальным для простых сервисов.
- SOAP: Более сложен в использовании, так как требует четкой спецификации операций через WSDL (Web Services Description Language). SOAP строго определяет формат сообщений и требует использования дополнительных механизмов (например, для обработки ошибок).
4. Гибкость и стандартизация
- REST: Более гибкий и не навязывает жестких стандартов. Он позволяет разработчику выбирать любой формат данных, кэширование, методы аутентификации и так далее. REST может адаптироваться к различным требованиям.
- SOAP: Строго регламентирован. Все операции и сообщения стандартизированы (через XML и WSDL). SOAP поддерживает множество стандартов (например, WS-Security, WS-ReliableMessaging), что делает его предпочтительным в сложных корпоративных средах.
5. Надежность и безопасность
- REST: Может использовать стандартные методы безопасности HTTP, такие как SSL/TLS (HTTPS) для шифрования. Однако REST не поддерживает встроенные стандарты для сложной безопасности и транзакционности.
- SOAP: Обладает встроенной поддержкой расширенных стандартов безопасности через WS-Security. Это позволяет реализовать шифрование, цифровые подписи и управление безопасностью на уровне сообщения. SOAP также поддерживает надежную доставку сообщений через WS-ReliableMessaging и транзакции (например, ACID).
6. Применение и использование
- REST: Идеален для взаимодействия с легкими веб-приложениями, мобильными приложениями, микросервисами и API, которые не требуют сложных транзакционных механизмов или повышенной безопасности. REST API легко кэшируются и масштабируются.
- SOAP: Предпочтителен для корпоративных приложений, требующих сложных транзакций, высокой степени безопасности и надежности (например, банковские системы, системы ERP, системы управления ресурсами). SOAP часто используется для интеграции бизнес-систем и взаимодействия в закрытых корпоративных сетях.
7. Кэширование
- REST: Позволяет легко кэшировать данные, так как использует стандартные HTTP-заголовки для управления кэшированием. Это повышает производительность, особенно при повторяющихся запросах.
- SOAP: Не поддерживает кэширование напрямую, так как запросы SOAP всегда направлены на выполнение операций, а не на чтение данных.
8. Стандарты для описания API
- REST: Обычно не требует обязательного описания API, хотя для документирования часто используют инструменты, такие как Swagger или OpenAPI. REST не зависит от таких форматов, что делает его более гибким.
- SOAP: Использует WSDL (Web Services Description Language) для точного описания интерфейса веб-сервиса. Это позволяет клиенту точно знать, какие операции поддерживаются и какие параметры передаются.
9. Производительность
- REST: Обычно быстрее, поскольку использует легкие форматы данных (например, JSON), и запросы более минималистичны по сравнению с SOAP. REST-сервисы также легче кэшируются, что может повысить производительность.
- SOAP: Медленнее из-за использования тяжелого формата XML, большого количества метаданных и дополнительных проверок безопасности, если они включены.

54) JSON Schema - это?
JSON Schema — это спецификация для описания структуры и проверки данных в формате JSON. 
Схема JSON предоставляет способ определить правила для данных JSON, чтобы гарантировать, что они соответствуют определенным требованиям. Она похожа на механизм валидации и описания типов данных, которые могут быть использованы в веб-приложениях, API и других системах, работающих с JSON.
Основные возможности JSON Schema:
1. Определение структуры данных:
JSON Schema позволяет точно описать, какие поля должны присутствовать в объекте, их типы (например, строки, числа, массивы, объекты), какие поля обязательны, какие — опциональны, и другие характеристики.
2. Валидация данных:
С помощью схемы можно проверить, соответствуют ли предоставленные данные заранее определенной структуре. Это помогает предотвратить ошибки, связанные с некорректными форматами данных.
3. Документация:
JSON Schema также может служить для описания API или форматов данных, позволяя разработчикам легко понять, что требуется от них при передаче данных в JSON-формате.

55) Что такое JSON и XML?
JSON (JavaScript Object Notation)
JSON — это легковесный текстовый формат обмена данными, основанный на синтаксисе объектов JavaScript, хотя используется в разных языках программирования. JSON стал популярным благодаря своей простоте и компактности, особенно для веб-приложений и API.
Основные характеристики JSON:
1. Простота и легкость: JSON имеет минималистичный синтаксис, что делает его легким для чтения и записи.
2. Читаемость: JSON формат легко читается и пишется как людьми, так и машинами.
3. Синтаксис объектов JavaScript: JSON состоит из ключей (строк) и значений, разделенных двоеточием, где ключи и строки заключаются в кавычки.
4. Компактность: JSON обычно занимает меньше места, чем XML, так как не требует описательных тегов.
Применение JSON:
- API и веб-приложения: JSON широко используется в веб-разработке для передачи данных между клиентом (например, браузером) и сервером.
- Хранение конфигураций: JSON часто используется для хранения настроек или конфигураций приложений.
- Обмен данными между системами: JSON часто используется для интеграции между разными системами или микросервисами.

XML (Extensible Markup Language)
XML — это расширяемый язык разметки, разработанный для хранения и передачи данных в иерархическом формате. XML широко использовался до появления JSON и продолжает применяться в некоторых системах, особенно в корпоративных приложениях.
Основные характеристики XML:
1. Гибкость: XML можно адаптировать для описания любых данных за счет расширяемости. Пользователи могут определять собственные теги для описания данных.
2. Читаемость и машиночитаемость: XML хорошо структурирован, что делает его понятным как для людей, так и для программ.
3. Тегированная структура: Данные описываются с помощью парных тегов, что позволяет выразить иерархическую структуру.
4. Самоописательность: Теги в XML содержат информацию о типе данных, что упрощает их понимание и обработку.
Применение XML:
- Обмен данными в сложных системах: XML используется в корпоративных приложениях и в протоколах, таких как SOAP, для обмена сложными данными.
- Документирование: XML используется в формате документов (например, в офисных форматах, таких как DOCX, которые основаны на XML).
- Конфигурационные файлы: XML также используется для описания конфигураций программ.

56) Каким форматом данных могут быть ключи в JSON?
String

57) Каким форматом данных могут быть значения в JSON?
- Строки (string) — текстовые данные, заключенные в двойные кавычки.
- Числа (number) — целые и дробные числа.
- Логические значения (boolean) — два значения: true или false.
- Массивы (array) — упорядоченные списки значений, заключенные в квадратные скобки [].
- Объекты (object) — наборы пар "ключ-значение", заключенные в фигурные скобки {}.
- null — специальное значение, которое обозначает отсутствие данных.

58) Какие невалидные типы данных есть у JSON?
1. Функции (Functions)
JSON не поддерживает функции или любой исполняемый код.
2. Неопределенные значения (undefined)
Значение undefined, используемое в JavaScript для обозначения переменных без значения, недопустимо в JSON.
3. Дата (Date)
JSON не имеет встроенного типа данных для представления дат. Обычно даты передаются в виде строк.
4. Инфинити и NaN
Значения Infinity, -Infinity и NaN (Not a Number), которые допустимы в JavaScript, недопустимы в JSON.
5. Комментарии
В JSON нельзя использовать комментарии. В отличие от некоторых языков разметки или программирования, JSON не поддерживает синтаксис комментариев (// или /* */).
6. Специальные объекты (например, RegExp)
7. Циклические ссылки
JSON не может содержать циклические ссылки, когда объект ссылается на себя или через другие объекты. Попытка сериализации таких объектов приведет к ошибке.

59) Что такое WSDL
WSDL (Web Services Description Language) — это язык описания веб-сервисов, основанный на XML. Он используется для формального определения интерфейсов веб-сервисов, чтобы клиенты могли взаимодействовать с ними без необходимости изучать внутренние детали их реализации. В основном, WSDL применяется для описания SOAP веб-сервисов, хотя может поддерживать и другие протоколы.
Основные характеристики WSDL:
1. Описание интерфейса веб-сервиса: WSDL определяет, какие методы и операции доступны через веб-сервис, какие типы данных передаются и возвращаются, а также какие протоколы и URL-адреса используются для взаимодействия с сервисом.
2. Формат на основе XML: WSDL документ — это XML-файл, который содержит структурированное описание веб-сервиса. Он включает описание операций, сообщений, типов данных и протоколов.
3. Независимость от платформы и языка: Так как WSDL основан на XML, его можно использовать в любых языках программирования и на любых платформах, поддерживающих XML и SOAP.

60) Что такое WADL
WADL (Web Application Description Language) — это язык описания веб-приложений, который используется для документирования RESTful веб-сервисов. Подобно тому, как WSDL используется для описания SOAP веб-сервисов, WADL описывает REST-сервисы, указывая доступные ресурсы, методы и типы данных, которые могут быть переданы или возвращены в ответе.
Основные характеристики WADL:
1. Описание REST API: WADL предоставляет формальное описание RESTful API, включая методы HTTP (GET, POST, PUT, DELETE и т.д.), URI ресурсов и структуры запросов/ответов.
2. Формат на основе XML: WADL-документ, как и WSDL, основан на XML, что делает его машиночитаемым и подходящим для автоматической генерации клиентского кода или документации.
3. Поддержка HTTP-методов: В отличие от SOAP, который использует только один протокол (обычно HTTP POST), WADL поддерживает различные HTTP-методы, такие как GET, POST, PUT, DELETE, HEAD и т.д.
4. Меньшая популярность по сравнению с WSDL: Несмотря на аналогичность WSDL для SOAP, WADL получил меньшее распространение, поскольку REST-сервисы обычно документируются с помощью других методов, таких как OpenAPI (Swagger).

61) Что такое логи?
Логи (или журналы событий) — это записи о действиях, событиях и процессах, происходящих в системе, приложении или на сервере. Логи используются для отслеживания работы программ, диагностики ошибок, мониторинга безопасности и анализа поведения системы. Они представляют собой текстовые файлы или структурированные данные, которые записывают информацию о том, что и когда произошло.
операций, для целей аудита и отслеживания действий пользователей.

62) Что такое логирование?
Логирование — это процесс записи событий, действий и состояний в систему или приложение с целью их последующего анализа, мониторинга и отладки. Логирование позволяет разработчикам и системным администраторам отслеживать, что происходит внутри программы или системы, фиксируя важные данные в логах (журналах).

63) Перечислите типы логов
1. По источнику:
- Системные логи:
Записывают события операционной системы, такие как загрузка, завершение работы, ошибки драйверов и другие системные события.
- Приложенческие логи:
Создаются конкретными приложениями и фиксируют их работу, ошибки, запросы пользователей и другую важную информацию.
- Логи безопасности:
Содержат информацию о событиях, связанных с безопасностью, таких как попытки входа в систему, неудачные авторизации и другие действия пользователей.
- Сетевые логи:
Записывают события, связанные с сетевыми взаимодействиями, такие как соединения, передача данных и ошибки сети.
2. По содержанию:
- Логи ошибок (Error logs):
Записывают сообщения об ошибках, которые произошли в системе или приложении. Эти логи помогают разработчикам и администраторам выявлять и устранять проблемы.
- Логи доступа (Access logs):
Фиксируют информацию о запросах, сделанных к ресурсам, включая IP-адреса, запрашиваемые URL, время запроса и статус ответа. Они полезны для анализа трафика и использования системы.
- Трассировочные логи (Trace logs):
Предназначены для детальной отладки приложения и содержат подробную информацию о последовательности выполнения кода. Полезны для понимания того, как выполняется программа.
- Логи аудита (Audit logs):
Записывают действия пользователей и изменения в системе для целей аудита и соответствия нормативным требованиям. Они важны для отслеживания несанкционированных действий.
3. По уровню важности:
- DEBUG:
Подробная информация, полезная для отладки приложения. Используется в процессе разработки для выявления проблем.
- INFO:
Общая информация о нормальной работе приложения, полезная для понимания его состояния.
- WARNING:
Предупреждения о потенциальных проблемах, которые могут потребовать внимания, но не являются критическими.
- ERROR:
Сообщения об ошибках, которые произошли в приложении, но не привели к его завершению.
- CRITICAL:
Критические ошибки, которые могут привести к сбоям в работе приложения или системы.
4. По способу хранения:
- Логи в текстовом формате:
Простые текстовые файлы, которые можно открыть и прочитать. Часто используются в системных и приложенческих логах.
- Структурированные логи:
Логи, представленные в формате, который легко анализировать, например, JSON или XML. Упрощает автоматизированный анализ и обработку данных.
- Двухуровневые логи:
Используют временные метки и уникальные идентификаторы для связи событий. Это позволяет лучше отслеживать и анализировать последовательности действий.

64) Механизм записи информации в логи
1. Выбор библиотек для логирования
Для записи логов часто используются специализированные библиотеки или фреймворки, которые упрощают процесс. 
2. Определение уровней логирования
Перед записью логов необходимо определить уровни важности (severity levels), такие как DEBUG, INFO, WARNING, ERROR и CRITICAL. Это помогает классифицировать сообщения и управлять объемом информации, фиксируемой в логах.
3. Создание логгера
В большинстве библиотек нужно создать объект логгера, который будет использоваться для записи сообщений. Это может включать настройку формата сообщений, уровня важности и других параметров.
4. Запись сообщений в логи
После настройки логгера, можно записывать сообщения с помощью методов, соответствующих уровням важности. Например:
logger.debug("Это отладочное сообщение")
logger.info("Это информационное сообщение")
5. Выбор метода вывода логов
Логи могут выводиться различными способами:
- В файл: Логи записываются в текстовые файлы на диске. Это позволяет сохранять историю событий и проводить анализ в дальнейшем.
- На консоль: Логи выводятся в стандартный вывод (консоль), что полезно для разработки и тестирования.
- В удаленные системы: Логи могут отправляться на удаленные серверы или системы мониторинга для централизованного хранения и анализа.
6. Ротация логов
Для предотвращения переполнения дискового пространства и управления объемом логов можно настроить ротацию логов. Это включает автоматическую архивацию и удаление старых логов. Многие библиотеки предоставляют встроенные механизмы для ротации.
7. Форматирование логов
Формат сообщений в логах можно настраивать в зависимости от нужд. Например, можно включать временные метки, уровень важности, идентификаторы сессий и другие параметры, которые помогут в дальнейшем анализе.
8. Обработка исключений
Логирование исключений также является важным аспектом. В случае возникновения ошибки можно использовать специальный метод для записи стека вызовов и деталей ошибки.

65) Зачем нужны логи? Какие инструменты знаете для сбора логов?
Основные цели логов:
1. Диагностика ошибок: Логи помогают разработчикам и системным администраторам выявлять и устранять ошибки. Когда происходит сбой или непредвиденное поведение, логи могут показать, что вызвало проблему.
2. Мониторинг работы: Логи позволяют отслеживать состояние системы или приложения в реальном времени. Это помогает убедиться, что система работает корректно, и выявлять потенциальные проблемы.
3. Безопасность: В логах фиксируются события, связанные с доступом к системе (вход в систему, неудачные попытки авторизации и т. д.), что важно для отслеживания подозрительных действий и обеспечения безопасности.
4. Анализ производительности: Логи могут использоваться для анализа производительности приложений или системы — например, сколько времени заняло выполнение определенной операции.
5. Аудит: Логи могут фиксировать важные события, такие как изменения в конфигурации или выполнение критических 
Инструменты:
1. ELK-стек:
- Elasticsearch: Мощная поисковая и аналитическая система, которая позволяет индексировать и искать данные.
- Logstash: Инструмент для сбора, преобразования и отправки данных в Elasticsearch.
- Kibana: Веб-интерфейс для визуализации и анализа данных, хранящихся в Elasticsearch.
2. Graylog:
Платформа для централизованного управления логами, которая позволяет собирать, индексировать и анализировать данные. Graylog предоставляет мощные инструменты для визуализации и поиска.
3. Splunk:
Коммерческое решение для анализа логов и мониторинга, которое поддерживает широкий спектр источников данных и предлагает мощные функции поиска и отчетности.
4. Fluentd:
Инструмент для сбора и агрегации логов, который позволяет отправлять данные в различные базы данных и системы мониторинга.
5. Loggly:
Облачный сервис для анализа и мониторинга логов, который предлагает функции поиска и визуализации данных.
6. Papertrail:
Облачный сервис для сбора и управления логами, который позволяет легко просматривать и анализировать данные в реальном времени.
7. Promtail и Loki:
- Promtail: Инструмент для сбора логов, который работает с Grafana Loki.
- Loki: Система для хранения логов, разработанная для интеграции с Grafana, предлагающая простое хранение и поиск логов.
8. Sentry:
Инструмент для мониторинга и отслеживания ошибок в приложениях, который собирает информацию о сбоях и исключениях, а также предоставляет анализ.
9. Nagios:
Система мониторинга, которая может отслеживать журналы и уведомлять о проблемах, связанных с работой серверов и приложений.

68) Привести примеры, когда QA-специалисту необходимо собрать логи с помощью Kibana
1. Анализ ошибок и сбоев в приложении
- Ситуация: Во время тестирования нового функционала приложения QA-специалист заметил, что приложение неожиданно выдает ошибки.
- Действие: QA-специалист использует Kibana для поиска и фильтрации логов, связанных с ошибками (например, по уровню ERROR или CRITICAL). Он может просмотреть стек вызовов и контекст, в котором произошла ошибка, что поможет понять, в чем заключается проблема и как её можно исправить.
2. Мониторинг производительности
- Ситуация: При тестировании приложения наблюдаются задержки в ответах сервера, и QA-специалист хочет выяснить причину.
- Действие: QA-специалист собирает логи, чтобы проанализировать время отклика на запросы, частоту возникновения задержек и любые связанные с этим ошибки. В Kibana можно визуализировать временные ряды, чтобы увидеть, как производительность меняется во времени.
3. Проверка корректности работы функционала
- Ситуация: После обновления приложения QA-специалист хочет убедиться, что все функции работают корректно и не вызывают ошибок.
- Действие: QA-специалист использует Kibana для анализа логов, чтобы проверить, правильно ли обрабатываются запросы и возвращаются ли ожидаемые ответы. Он может искать конкретные события или действия, чтобы убедиться, что все работает как задумано.
4. Анализ аномалий и подозрительных действий
- Ситуация: В процессе тестирования QA-специалист замечает, что некоторые пользователи жалуются на необычное поведение приложения.
- Действие: QA-специалист собирает логи из Kibana, чтобы выявить любые аномалии или подозрительные действия, такие как необычные запросы, частые ошибки или несанкционированные действия пользователей. Это может помочь выявить потенциальные проблемы с безопасностью или производительностью.
5. Отслеживание событий и транзакций
- Ситуация: QA-специалист проводит тестирование сценариев использования, и необходимо проверить последовательность событий.
- Действие: В Kibana QA-специалист может отслеживать конкретные идентификаторы сессий или транзакций, чтобы увидеть, какие действия выполнялись пользователями и как система на них реагировала. Это позволяет убедиться, что все события правильно фиксируются и обрабатываются.
6. Создание отчетов о тестировании
- Ситуация: QA-специалист хочет подготовить отчет о состоянии системы после тестирования.
- Действие: Используя Kibana, QA-специалист может собрать данные о количестве ошибок, успешных запросах, времени отклика и других метриках, чтобы включить их в отчет. Это поможет команде разработчиков понять, какие проблемы требуют внимания.
7. Проверка целостности данных
- Ситуация: После миграции данных или обновления системы необходимо убедиться, что данные корректно перенесены.
- Действие: QA-специалист использует Kibana для анализа логов, чтобы проверить, не возникли ли ошибки во время миграции, и все ли данные были правильно записаны и доступны.

69) Что такое DNS?
DNS (Domain Name System) — это система, которая переводит удобные для человека доменные имена в числовые IP-адреса, которые используются для идентификации устройств в сети. 

70) Что такое IP адрес?
IP-адрес (Internet Protocol address) — это уникальный числовой идентификатор, который используется для определения устройства в сети, будь то компьютер, сервер, маршрутизатор или другое устройство, подключенное к Интернету или локальной сети. IP-адрес позволяет устройствам обмениваться данными, находя друг друга в сети.
Типы IP-адресов:
1. IPv4 (Internet Protocol version 4):
- Наиболее распространённый формат IP-адресов, состоящий из 32 бит (4 байта).
- Представляется в виде четырех десятичных чисел, разделенных точками (например, 192.168.1.1).
2. IPv6 (Internet Protocol version 6):
- Новый формат IP-адресов, разработанный для решения проблемы нехватки адресов IPv4.
- Состоит из 128 бит (16 байт) и представляется в виде восьми групп шестнадцатеричных чисел, разделенных двоеточиями (например, 2001:0db8:85a3:0000:0000:8a2e:0370:7334).
Классификация IP-адресов:
1. Статические IP-адреса:
Адреса, которые не меняются и назначаются устройствам на постоянной основе. Они обычно используются для серверов, которые должны быть всегда доступными по одному и тому же адресу.
2. Динамические IP-адреса:
Адреса, которые могут изменяться с течением времени. Они назначаются устройствам автоматически через DHCP (Dynamic Host Configuration Protocol) и часто используются в домашних сетях и для клиентских устройств.

71) Что такое порт?
Порт — это логический интерфейс, который используется в компьютерных сетях для идентификации конкретного приложения или сервиса на устройстве, подключенном к сети. Порты позволяют различным приложениям и сервисам на одном и том же IP-адресе одновременно обмениваться данными без конфликтов.
Основные функции портов:
1. Идентификация приложений: Порты помогают маршрутизировать входящие и исходящие данные к правильным приложениям или процессам на устройстве. Например, веб-сервер и почтовый сервер могут работать на одном IP-адресе, но использовать разные порты для обработки запросов.
2. Управление сетевыми соединениями: Порты позволяют управлять сетевыми соединениями, обеспечивая возможность одновременно работать нескольким приложениям и пользователям.
Как работают порты:
Когда устройство отправляет или получает данные по сети, оно указывает как IP-адрес, так и номер порта:
1. Отправка данных:
- Когда клиентское приложение (например, веб-браузер) отправляет запрос на сервер, оно указывает IP-адрес сервера и номер порта, на который отправляется запрос (например, 80 для HTTP).
- Сервер получает запрос, обрабатывает его на соответствующем порту и отправляет ответ обратно на клиент.
2. Получение данных:
- Сервер слушает на определённом порту, ожидая входящие соединения. Когда запрос поступает, сервер обрабатывает его и отправляет ответ обратно на клиентский порт.

72) Что такое хост?
Хост — это общее название для любого устройства, которое подключено к сети и может отправлять или принимать данные. В контексте компьютерных сетей хостами могут быть различные устройства, такие как компьютеры, серверы, маршрутизаторы, принтеры и другие устройства, которые имеют уникальный сетевой адрес (например, IP-адрес).

73) Что такое URL
URL (Uniform Resource Locator) — это стандартный адрес, используемый для идентификации ресурса в Интернете и указания его местоположения. URL позволяет пользователям и приложениям находить и получать доступ к ресурсам, таким как веб-страницы, изображения, видео и другие типы контента.

74) В чем разница между URI, URL, URN?

- URI (Uniform Resource Identifier):
Например, https://www.example.com/page — это URI, который идентифицирует ресурс на сайте.
- URL (Uniform Resource Locator):
Это тот же пример, https://www.example.com/page, поскольку он указывает на конкретное местоположение ресурса и как к нему получить доступ.
- URN (Uniform Resource Name):
Допустим, у нас есть уникальный идентификатор для страницы, который не указывает, где ее найти, например, urn:example:page123. Это будет URN, идентифицирующий конкретную страницу, но не дающий информации о её местоположении.
В этом случае:
https://www.example.com/page — это и URI, и URL.
urn:example:page123 — это URN.


75) Из чего состоит url адрес?
- Схема (или протокол):
https:// — указывает протокол, который используется для доступа к ресурсу. Это может быть http, https, ftp, mailto и др. 
- Хост (или доменное имя):
www.example.com — указывает на сервер, на котором находится ресурс. Это может быть доменное имя (например, example.com) или IP-адрес.
- Порт (необязательный):
:443 — указывает на номер порта, который используется для соединения. Если порт не указан, используются стандартные значения (80 для HTTP и 443 для HTTPS).
- Путь:
/path/to/resource — указывает путь к конкретному ресурсу на сервере. Это может быть путь к файлу или к определенной странице.
- Строка запроса (необязательный):
?query=parameter — используется для передачи параметров в запрос. .
- Якорь (или фрагмент) (необязательный):
#fragment — указывает на определённую часть ресурса, например, на определённый раздел веб-страницы. Якорь начинается с символа #.

76) Что происходит после ввода запроса в адресную строку?
1. Разрешение доменного имени
DNS-запрос: Браузер проверяет, есть ли уже кешированный IP-адрес для введенного доменного имени. Если нет, он отправляет запрос к DNS-серверу (Domain Name System) для разрешения доменного имени в IP-адрес.
Ответ от DNS: DNS-сервер возвращает IP-адрес, связанный с доменным именем. Например, если вы ввели www.example.com, DNS-сервер вернет его IP-адрес (например, 192.0.2.1).
2. Установка соединения
- TCP-соединение: После получения IP-адреса браузер устанавливает соединение с сервером, используя TCP (Transmission Control Protocol). Этот процесс включает:
Трехстороннее рукопожатие: Браузер отправляет SYN-запрос на сервер, сервер отвечает SYN-ACK, и браузер завершает процесс, отправляя ACK.
- Безопасное соединение (при необходимости): Если используется HTTPS, происходит дополнительный этап — TLS/SSL-рукопожатие, где устанавливается зашифрованное соединение.
3. Отправка HTTP-запроса
- Формирование HTTP-запроса: Браузер формирует HTTP-запрос (или HTTPS-запрос) для запрашиваемого ресурса. Запрос включает:
Метод (например, GET, POST)
URL-адрес
Заголовки (например, User-Agent, Accept)
(для POST) тело запроса с данными
- Отправка запроса: HTTP-запрос отправляется на сервер по установленному соединению.
4. Обработка запроса сервером
- Обработка запроса: Веб-сервер принимает HTTP-запрос и обрабатывает его. Это может включать:
Поиск запрашиваемого ресурса (например, HTML-страницы, изображения, данные из базы данных).
Выполнение бизнес-логики (например, обработка форм, аутентификация пользователей).
- Формирование ответа: Сервер формирует HTTP-ответ, который включает:
Статус-код (например, 200 OK, 404 Not Found)
Заголовки (например, Content-Type, Content-Length)
Тело ответа с содержимым ресурса (например, HTML-код)
5. Получение и отображение ответа
- Получение ответа: Браузер получает HTTP-ответ от сервера.
- Отображение контента: Браузер обрабатывает ответ и отображает его на экране. Это включает:
Интерпретацию HTML-кода, CSS и JavaScript.
Загрузка дополнительных ресурсов, таких как изображения, скрипты и стили, если они указаны в HTML.
6. Кеширование и хранение данных
- Кеширование: Браузер может кешировать ресурсы (например, изображения, страницы) для ускорения загрузки при последующих запросах.
- Локальное хранилище: Если веб-приложение использует локальное хранилище (например, cookies, Local Storage), данные могут быть сохранены для использования в будущем.

77) Что такое HTTP?
HTTP (Hypertext Transfer Protocol) — это протокол, используемый для передачи данных в Интернете. Он является основой для передачи и получения информации в веб-приложениях и представляет собой стандартный способ общения между клиентом (например, веб-браузером) и сервером (например, веб-сервером).
Основные характеристики HTTP:
1. Протокол прикладного уровня: HTTP работает на прикладном уровне модели OSI и служит для передачи данных, таких как HTML-документы, изображения, видео и другие ресурсы.
2. Клиент-серверная архитектура: Взаимодействие в HTTP происходит по модели "клиент-сервер". Клиент отправляет запросы к серверу, а сервер обрабатывает эти запросы и отправляет ответы обратно клиенту.
3. Безсостояние (Stateless): Каждый HTTP-запрос обрабатывается независимо, без сохранения состояния между запросами. Это означает, что сервер не хранит информацию о предыдущих запросах от клиента. Это упрощает архитектуру, но для поддержания состояния используются другие механизмы, такие как cookies и сессии.
4. Методы HTTP: HTTP поддерживает различные методы, которые определяют тип действия, которое нужно выполнить. 
5.Статусы HTTP: Сервер отвечает на запросы с помощью статус-кодов, которые информируют клиента о результате обработки запроса. 
6. Заголовки HTTP: Заголовки содержат метаданные о запросе или ответе, такие как тип контента, длина тела, настройки кэширования и т. д. Примеры заголовков:

78) Что такое HTTPS?
HTTPS (Hypertext Transfer Protocol Secure) — это расширение протокола HTTP, которое обеспечивает безопасную передачу данных в Интернете. HTTPS сочетает в себе протокол HTTP с протоколами шифрования, такими как TLS (Transport Layer Security) или SSL (Secure Sockets Layer), для защиты данных, передаваемых между клиентом (например, веб-браузером) и сервером.
Основные характеристики HTTPS:
1. Шифрование данных: При использовании HTTPS данные шифруются, что делает их недоступными для третьих лиц во время передачи. Это защищает конфиденциальную информацию, такую как пароли, номера кредитных карт и личные данные, от перехвата.
2. Аутентификация: HTTPS обеспечивает проверку подлинности сервера. При установлении соединения браузер проверяет, что сервер действительно тот, за кого он себя выдает, путем проверки цифрового сертификата, выданного доверенным центром сертификации (CA). Это помогает предотвратить атаки типа "человек посередине" (MITM), когда злоумышленник может попытаться перехватить или изменить данные.
3. Целостность данных: HTTPS гарантирует, что данные не были изменены или повреждены во время передачи. Если данные были модифицированы, соединение будет разорвано, и пользователь получит предупреждение.
4. Порт: HTTPS по умолчанию использует порт 443, в отличие от HTTP, который использует порт 80.
Принципы работы HTTPS
1. TLS/SSL-рукопожатие: Когда браузер устанавливает HTTPS-соединение с сервером, происходит процесс, называемый "рукопожатие". В ходе этого процесса:
- Браузер запрашивает сертификат сервера.
- Сервер отправляет свой сертификат браузеру.
- Браузер проверяет сертификат у центра сертификации.
- Если сертификат действителен, устанавливается зашифрованное соединение.
2. Шифрование: После успешного рукопожатия данные между клиентом и сервером шифруются с использованием симметричного шифрования. Это означает, что один и тот же ключ используется для шифрования и расшифровки данных.

79) SSL и TLS - это?
SSL (Secure Sockets Layer) и TLS (Transport Layer Security) — это криптографические протоколы, используемые для обеспечения безопасности передачи данных по сети, в частности, в интернете.
SSL (Secure Sockets Layer)
SSL обеспечивает конфиденциальность и целостность передаваемой информации с помощью:
1. Шифрование: Данные перед отправкой шифруются.
2. Аутентификация: Удостоверение личности веб-сервера с помощью SSL-сертификата, подтверждающего, что сайт является подлинным.
3. Целостность данных: Данные не могут быть изменены или повреждены во время передачи.
TLS (Transport Layer Security)
TLS — это усовершенствованная и более безопасная версия SSL. Он был разработан как замена SSL для устранения уязвимостей и улучшения шифрования.
Основные различия между SSL и TLS:
1. Безопасность: TLS обеспечивает более высокий уровень безопасности, чем SSL.
2. Эффективность: В TLS улучшен процесс шифрования и аутентификации, что делает его более быстрым.
3. Устраненные уязвимости: TLS устраняет известные уязвимости в SSL, такие как атаки на шифрование и возможность подмены сообщений.

80) TCP/IP - это?
TCP/IP (Transmission Control Protocol/Internet Protocol) — это набор сетевых протоколов, который обеспечивает связь и передачу данных в интернете и других сетях. Он является основой для работы интернета и позволяет устройствам общаться между собой независимо от их архитектуры, операционной системы или типа сети.

Основные компоненты TCP/IP:
TCP (Transmission Control Protocol) — протокол транспортного уровня, отвечающий за надежную передачу данных.
IP (Internet Protocol) — протокол сетевого уровня, который определяет, как данные передаются от одного узла к другому по сети.

Основные функции:
TCP (Протокол управления передачей):
- Надежность: TCP гарантирует, что данные доставляются в правильной последовательности, даже если они были разбиты на пакеты.
- Контроль потока: Следит за тем, чтобы отправитель не отправлял данные быстрее, чем их может принять получатель.
- Контроль ошибок: Проверяет целостность данных с помощью контрольных сумм и повторно отправляет поврежденные или потерянные пакеты.
- Управление соединением: TCP устанавливает соединение (трехфазное рукопожатие) перед передачей данных и разрывает его по завершении.

IP (Интернет-протокол):
- Маршрутизация: IP отвечает за адресацию и маршрутизацию данных. Он определяет, через какие устройства данные должны пройти, чтобы достичь назначения.
- Адресация: Каждому устройству в сети присваивается уникальный IP-адрес, который используется для идентификации отправителя и получателя данных.
- Фрагментация: IP делит большие данные на более мелкие пакеты для удобства передачи по сети.


81) Уровни TCP/IP?
Структура модели TCP/IP:
Модель TCP/IP состоит из четырех уровней, которые описывают процесс передачи данных от одного устройства к другому:
1. Уровень сетевого доступа (канальный) (Link Layer): Определяет, как данные физически передаются по локальной сети (например, Ethernet, Wi-Fi). Здесь происходит работа с MAC-адресами и физической передачей пакетов.
2. Сетевой уровень (Internet Layer): Определяет маршрутизацию данных между устройствами в разных сетях. Главным протоколом здесь является IP, который доставляет пакеты от отправителя к получателю.
3. Транспортный уровень (Transport Layer): Обеспечивает надежную передачу данных между приложениями на разных устройствах. Здесь используются два основных протокола:
- TCP — для надежной передачи с проверкой целостности.
- UDP (User Datagram Protocol) — более быстрый, но менее надежный протокол, используется там, где важна скорость (например, потоковое видео).
4. Прикладной уровень (Application Layer): Здесь работают протоколы, которые напрямую взаимодействуют с пользователями и приложениями. Примеры таких протоколов:
- HTTP/HTTPS — для веб-страниц.
- FTP — для передачи файлов.
- SMTP/IMAP/POP3 — для электронной почты.
- DNS — для разрешения доменных имен в IP-адреса.


Пример работы TCP/IP:
Когда вы посещаете веб-сайт:
Ваш браузер отправляет запрос по протоколу HTTP (уровень приложений).
Запрос передается через TCP, который разбивает данные на пакеты (транспортный уровень).
IP отвечает за то, чтобы эти пакеты дошли до нужного сервера (сетевой уровень).
После получения ответа сервер снова использует TCP для отправки данных обратно, и браузер отображает веб-страницу.

82) Уровни OSI?
Уровни модели OSI (Open Systems Interconnection) включают в себя семь уровней:
1. Физический уровень (Physical Layer): Определяет электрические и физические характеристики передачи данных (кабели, разъемы, сигналы).
2. Канальный уровень (Data Link Layer): Отвечает за надежную передачу данных между соседними устройствами, управление доступом к среде и обработку ошибок.
3. Сетевой уровень (Network Layer): Обеспечивает маршрутизацию данных между устройствами в разных сетях. Здесь работают IP-адресация и маршрутизация.
4. Транспортный уровень (Transport Layer): Гарантирует надежную передачу данных между конечными узлами. Использует протоколы, такие как TCP и UDP.
5. Сеансовый уровень (Session Layer): Управляет сессиями связи между приложениями, устанавливает, поддерживает и завершает соединения.
6. Представительский уровень (Presentation Layer): Обеспечивает преобразование данных в формат, удобный для приложения. Здесь выполняется шифрование и сжатие данных.
7. Прикладной уровень (Application Layer): На этом уровне работают прикладные программы и протоколы, предоставляющие услуги пользователям, такие как HTTP, FTP и SMTP.

83) Что такое FTP?
FTP (File Transfer Protocol) — это протокол передачи файлов, который используется для обмена файлами между компьютерами в сети, чаще всего в интернете. FTP позволяет пользователям загружать (upload) и скачивать (download) файлы на удалённые серверы.
Особенности FTP:
1. Работа в клиент-серверной модели: FTP требует наличие клиента (программного обеспечения для передачи файлов) и сервера (где хранятся файлы).
2. Аутентификация: Обычно для доступа к FTP-серверу требуется ввод логина и пароля, хотя существуют и анонимные FTP-серверы, где доступ возможен без авторизации.
3. Режимы передачи: FTP поддерживает два режима передачи данных — текстовый и бинарный, что позволяет передавать как текстовые файлы, так и медиафайлы.
4. Порты: По умолчанию FTP использует порты 21 для управления соединением и 20 для передачи данных.
5.Команды: Протокол включает команды для выполнения различных действий, таких как загрузка, скачивание, удаление и переименование файлов.
FTP широко используется для управления веб-сайтами, резервного копирования данных и обмена файлами между пользователями.

84) Какую структуру имеет веб-страница?
1. DOCTYPE: Указывает тип документа и версию HTML. Например:
<!DOCTYPE html>
2. Элемент <html>: Корневой элемент, который охватывает всю страницу.
<html lang="ru">
3. Элемент <head>: Содержит метаинформацию о странице, такую как:
- <title>: Заголовок страницы, отображаемый в вкладке браузера.
- <meta>: Метатеги для указания кодировки, авторства, описания и ключевых слов.
- <link>: Ссылки на внешние стили (CSS).
- <script>: Включение внешних или встроенных скриптов (JavaScript).
<head>
    <title>Пример веб-страницы</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="styles.css">
</head>
4. Элемент <body>: Содержит видимую часть страницы

85) Что такое HTML/CSS/JavaScript?
HTML (HyperText Markup Language) — это язык разметки, который используется для создания структуры веб-страниц. Он определяет элементы страницы, такие как заголовки, параграфы, ссылки, изображения и таблицы. HTML состоит из тегов, которые указывают браузеру, как отображать контент.
CSS (Cascading Style Sheets)— это язык стилей, который используется для оформления и визуального представления веб-страниц. С помощью CSS можно изменять цвет, шрифт, размер, отступы и другие параметры элементов, определенных в HTML.
JavaScript — это язык программирования, который добавляет интерактивность и динамичность на веб-страницы. С его помощью можно создавать анимации, обработчики событий, взаимодействовать с сервером и изменять содержимое страницы без перезагрузки.
Взаимодействие технологий:
- HTML создает структуру страницы.
- CSS отвечает за ее внешний вид.
- JavaScript добавляет интерактивность и динамику.

86) Что такое AJAX?
AJAX (Asynchronous JavaScript and XML) — это технология, которая позволяет обновлять веб-страницы асинхронно, не перезагружая их полностью. Это значит, что можно загружать данные с сервера и обновлять содержимое страницы по мере необходимости, что улучшает пользовательский опыт и делает взаимодействие более плавным.
Основные характеристики AJAX:
1. Асинхронность: AJAX позволяет отправлять запросы к серверу и получать данные без блокировки пользовательского интерфейса. Это означает, что пользователь может продолжать взаимодействовать с веб-страницей, пока данные загружаются.
2. Использование JavaScript: AJAX основан на JavaScript и обычно использует объект XMLHttpRequest или современный fetch API для выполнения запросов.
3. Поддержка различных форматов данных: Несмотря на название, AJAX может работать не только с XML, но и с JSON, HTML, текстом и другими форматами.
4. Улучшение производительности: AJAX позволяет загружать только необходимые данные, что снижает объем передаваемой информации и ускоряет загрузку страниц.
Применение AJAX:
- Динамическое обновление контента (например, загрузка новых сообщений в чате)
- Автозаполнение форм (например, предложения по мере ввода текста)
- Загрузка данных по запросу (например, страницы с результатами поиска)

87) Что такое адаптивная и респонсивная верстка?
Адаптивная и респонсивная верстка — это два подхода к созданию веб-дизайна, который хорошо отображается на различных устройствах и экранах. Они имеют разные методы реализации, но оба стремятся улучшить пользовательский опыт.
Адаптивная верстка (adaptive design) предполагает создание нескольких фиксированных версий страницы, каждая из которых оптимизирована для определенной ширины экрана. При загрузке страницы сервер определяет тип устройства и предоставляет соответствующую версию.
Характеристики:
- Использует несколько заранее заданных размеров макетов (например, для мобильных, планшетов и десктопов).
- Макеты могут быть статическими и не изменяются при изменении размера окна.
- Часто включает медиа-запросы для загрузки разных стилей в зависимости от размера экрана.
Преимущества:
- Быстрая загрузка, так как загружается только необходимый контент.
- Удобство для пользователей, так как каждая версия страницы оптимизирована для определенного устройства.
Недостатки:
- Требует больше времени и ресурсов для разработки и поддержки нескольких версий.
- Ограниченная гибкость, если размеры экранов пользователей не попадают в заданные диапазоны.

Респонсивная верстка (responsive design) предполагает создание единого макета, который адаптируется к размеру экрана с помощью гибких сеток, изображений и медиа-запросов.
Характеристики:
- Использует процентные значения для ширины элементов, что позволяет им изменять размер в зависимости от ширины окна.
- Применяет медиа-запросы для изменения стилей в зависимости от размера экрана.
- Один и тот же HTML-код используется для всех устройств.
Преимущества:
- Одна версия сайта для всех устройств, что упрощает поддержку.
- Гибкость и адаптивность для различных разрешений экранов.
- Улучшенный пользовательский опыт на всех устройствах.
Недостатки:
- Может потребоваться больше времени на загрузку, если не оптимизированы изображения и стили.
- Иногда сложнее реализовать точные макеты для разных устройств.

88) Как протестировать адаптивную верстку?
1. DevTools
2. Эмуляторы и симуляторы
- BrowserStack: Позволяет тестировать веб-приложения на реальных устройствах с различными браузерами и операционными системами.
- Responsive Design Mode в Firefox: Встроенный инструмент для проверки адаптивности.
3. Физические устройства
4. Медиа-запросы
Проверьте, правильно ли работают медиа-запросы, меняя размер окна браузера вручную и наблюдая за изменениями стилей.
5. Инструменты тестирования производительности
Используйте инструменты, такие как Google Lighthouse или GTmetrix, чтобы проверить производительность страницы на различных устройствах и выявить возможные проблемы с загрузкой и отображением.

89) Как выполнить Debug страницы в браузере?
1. Использование вкладок инструментов
- Elements: Позволяет просматривать и редактировать HTML и CSS. Вы можете изменять стили, проверять структуру документа и видеть, как изменения влияют на страницу в реальном времени.
- Console: Отображает сообщения об ошибках и позволяет выполнять JavaScript-код. Вы можете вводить команды и проверять значения переменных.
- Network: Показывает все сетевые запросы, включая загрузку ресурсов (изображения, скрипты и стили). Это полезно для анализа времени загрузки и выявления проблем.
- Sources: Позволяет просматривать и отлаживать JavaScript. Вы можете устанавливать точки останова (breakpoints), чтобы остановить выполнение кода и исследовать состояние программы.
- Performance: Позволяет анализировать производительность страницы, включая время загрузки и рендеринга.
- Application: Отображает информацию о локальном хранилище, cookies и других ресурсах, связанных с приложением.
2. Отладка JavaScript (вкладка Sources)
3. Просмотр ошибок и предупреждений (вкладка Console)
4. Тестирование запросов (вкладка Network)

90) Что такое WebSocket и как проверить обрыв соединения?
WebSocket — это протокол связи, который обеспечивает постоянное соединение между клиентом и сервером для обмена данными в реальном времени. Он позволяет устанавливать двусторонний канал связи, что делает его идеальным для приложений, требующих мгновенной передачи данных, таких как чаты, игры и финансовые приложения.
Основные характеристики WebSocket:
- Двусторонняя связь: Обе стороны (клиент и сервер) могут отправлять данные независимо друг от друга.
- Экономия ресурсов: После первоначального установления соединения обмен данными происходит с меньшими накладными расходами, чем при использовании HTTP.
- Состояние: WebSocket сохраняет состояние соединения, что позволяет передавать данные более эффективно.

Как проверить обрыв соединения WebSocket?
Проверка обрыва соединения WebSocket может выполняться различными способами. Вот основные подходы:
1. Обработка событий
WebSocket API предоставляет события, которые можно использовать для отслеживания состояния соединения.
- onclose: Это событие срабатывает, когда соединение закрывается. Вы можете использовать его, чтобы выполнить определенные действия, такие как попытка переподключения.
- onerror: Это событие срабатывает, когда возникает ошибка в соединении.
2. Периодические проверки
Вы можете настроить периодические проверки (ping/pong) для проверки активности соединения:
- Ping: Сервер периодически отправляет "ping" сообщения клиенту.
- Pong: Клиент отвечает "pong". Если сервер не получает ответ в течение заданного времени, он может считать соединение потерянным.
3. Проверка состояния соединения
Проверяйте состояние соединения с помощью свойства readyState объекта WebSocket

91) Как узнать схему API проекта
1. Документация API
- Официальная документация: Проверьте, есть ли у проекта официальная документация API. Обычно она включает описание эндпоинтов, параметров, методов запросов (GET, POST и т.д.), форматов ответов и ошибок.
- OpenAPI Specification (Swagger): Если проект использует OpenAPI, вы можете найти файл спецификации (обычно openapi.yaml или swagger.json), который описывает все эндпоинты и их параметры.
2. Инструменты разработки
- Postman: Если проект использует Postman для тестирования API, вы можете открыть коллекции API, которые содержат информацию о эндпоинтах, их параметрах и примерах запросов.
- Insomnia: Аналогично Postman, этот инструмент также может иметь коллекции с описанием API.
3. Код проекта
- Исходный код: Если у вас есть доступ к исходному коду проекта, посмотрите на файлы, отвечающие за маршрутизацию (например, в Node.js это может быть файл с определением маршрутов). Обычно в этих файлах можно найти описание эндпоинтов и их логики.
- Комментарии и аннотации: Проверьте наличие комментариев в коде, которые могут содержать описание API.
4. Инструменты для анализа API
- Swagger UI: Если проект использует Swagger, вы можете открыть интерфейс Swagger UI, который визуально представляет все доступные эндпоинты API и их параметры.
- GraphQL: Если API использует GraphQL, вы можете использовать инструменты, такие как GraphiQL или Apollo Studio, чтобы исследовать схему и доступные запросы.
5. Запросы к API
- Тестирование через cURL или Postman: 
- Логи сервера: Если у вас есть доступ к логам сервера, они могут содержать информацию о запросах, которые поступали в API.

92) Можно ли начать тестирование, если интерфейс (frontend) ещё не готов? Как?
1. Тестирование API
Если backend уже готов, вы можете тестировать API. Это включает:
- Функциональное тестирование: Проверка, что API возвращает ожидаемые результаты для различных запросов.
- Тестирование эндпоинтов: Используйте инструменты, такие как Postman или cURL, для отправки запросов и проверки ответов.
- Тестирование производительности: Проверка времени отклика и нагрузки на API с помощью инструментов, таких как JMeter или Locust.
2. Тестирование на уровне логики
- Юнит-тесты: Пишите юнит-тесты для отдельных функций или методов на backend. Это помогает убедиться, что логика приложения работает правильно.
- Интеграционные тесты: Проверяйте взаимодействие между различными модулями или компонентами.
3. Создание моков (mock)
- Мок-серверы: Если frontend ещё не готов, можно использовать мок-серверы (например, Mockoon или JSON Server) для имитации ответов API. Это позволяет тестировать логику frontend, даже если сам интерфейс ещё не реализован.
4. Тестирование пользовательского опыта (UX)
Если у вас есть прототипы или макеты интерфейса (например, созданные с помощью Figma или Adobe XD), вы можете проводить тесты на пользовательском опыте.
- Пользовательское тестирование: Попросите пользователей взаимодействовать с прототипами, чтобы получить обратную связь.
- Тестирование навигации: Оцените, насколько интуитивно понятен интерфейс, даже если он не реализован.
5. Автоматизированное тестирование
Вы можете начать разрабатывать автоматизированные тесты, которые будут запускаться, когда интерфейс будет готов.
- Тесты на уровне API: Напишите тесты, которые будут проверять взаимодействие между фронтендом и бэкендом.
- Тесты производительности: Настройте сценарии для тестирования производительности.
6. Непрерывная интеграция (CI)
Если у вас настроен CI/CD, интегрируйте тесты в процесс сборки, чтобы они автоматически запускались при каждом изменении кода.

93) Какие виды тестирования можно применить только к Web?
- Тестирование совместимости: Проверка работы веб-приложения в разных браузерах, версиях и на различных устройствах (мобильных, планшетах и т.д.).
- Тестирование производительности: Оценка быстродействия, нагрузки и масштабируемости веб-приложения под различными условиями.
- Тестирование безопасности: Выявление уязвимостей, таких как SQL-инъекции, XSS (межсайтовый скриптинг) и другие угрозы, специфичные для веб-среды.
- Тестирование пользовательского интерфейса (UI): Оценка удобства и восприятия интерфейса, включая тестирование элементов, таких как кнопки, формы и навигация.
- Тестирование API: Проверка работы веб-сервисов и взаимодействия с ними через REST или SOAP.
- Тестирование адаптивности: Оценка, как веб-приложение отображается и функционирует на различных экранах и разрешениях.
- Тестирование локализации: Проверка корректности отображения контента на разных языках и соответствия культурным особенностям.
- Тестирование кросс-доменных запросов: Оценка обработки запросов, исходящих с других доменов, особенно в контексте безопасности.

94) Каковы есть основные виды уязвимости веб-приложений?
1. SQL-инъекции (SQLi): Позволяет злоумышленнику выполнять произвольные SQL-запросы, что может привести к утечке данных или изменениям в базе данных.
2. Межсайтовый скриптинг (XSS): Позволяет вставлять вредоносные скрипты на страницы, которые будут выполнены в браузере пользователей.
3. Переполнение буфера (Buffer Overflow): Уязвимость, возникающая при неправильной обработке данных, что может привести к исполнению произвольного кода.
4. Уязвимости аутентификации и управления сессиями: Недостаточная защита паролей, использование слабых механизмов аутентификации или управление сессиями может привести к компрометации учетных записей.
5. Неконтролируемый доступ к объектам: Позволяет пользователям получить доступ к ресурсам, на которые у них нет прав, например, к данным других пользователей.
6. Ошибки конфигурации безопасности: Неправильная настройка серверов, баз данных или приложений может создать уязвимости.
7. Межсайтовые запросы (CSRF): Позволяет злоумышленнику заставить пользователя выполнить нежелательное действие на сайте, где он аутентифицирован.
8. Недостаточная защита данных: Хранение чувствительных данных (например, паролей) без шифрования или с использованием устаревших алгоритмов.
9. Исполнение произвольного кода: Уязвимости, которые позволяют злоумышленнику исполнять произвольные команды или скрипты на сервере.
10. Уязвимости в библиотеке и фреймворке: Использование устаревших или уязвимых сторонних библиотек и фреймворков может привести к компрометации безопасности приложения.

95) Какие инструменты для тестирования Web performance client-side знаете?
1. Google PageSpeed Insights: Оценка производительности страниц, включая рекомендации по улучшению скорости загрузки.
2. Lighthouse: Инструмент от Google для аудита производительности, доступности и SEO веб-страниц. Входит в состав Chrome DevTools.
3. GTmetrix: Анализирует производительность страницы и предоставляет детальные отчеты с рекомендациями по оптимизации.
4. WebPageTest: Позволяет проводить тесты производительности с разных локаций и браузеров, предоставляет подробные результаты.
5. Pingdom: Мониторинг скорости загрузки веб-сайта с отчетами о времени загрузки и производительности.
6. New Relic: Обширный инструмент для мониторинга производительности приложений, включая клиентскую часть.
7. Dynatrace: Инструмент для мониторинга и анализа производительности, включая работу с клиентской стороны.
8. BrowserStack: Позволяет тестировать производительность веб-приложений на различных устройствах и браузерах.
9. Fiddler: Инструмент для отладки HTTP-трафика, позволяет анализировать производительность запросов и ответов.
10. JMeter (с поддержкой браузеров): Основной инструмент для нагрузочного тестирования, который можно адаптировать для тестирования клиентской производительности.






